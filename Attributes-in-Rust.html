<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Attributes-in-Rust</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="Articles.html">Articles</a> <a href="Tags.html">Tags</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9776;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p></p><div id="settingsmenu"><table><thead><tr><th colspan="2"><div class="align-right"> <span class="size-giant"><a id="settingsclosebutton">&#10006;</a></span></div></th></tr></thead><tbody><tr><td><div class="align-right">Theme:</div></td><td><div class="align-left"><a id="changethemebutton">Set Light Theme</a></div></td></tr><tr><td><div class="align-right">Horizontal Padding:</div></td><td><div class="align-left"><a id="growhorizontalbutton">Grow</a> <a id="shrinkhorizontalbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Font Size:</div></td><td><div class="align-left"><a id="growfontbutton">Grow</a> <a id="shrinkfontbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Settings:</div></td><td><div class="align-left"><a id="savesettingsbutton">Save All</a> <a id="discardsettingsbutton">Discard All</a></div></td></tr></tbody></table></div></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<div class="align-right"><p>Last Updated: 12.May.2023</p><p>Tags: <a href="tag-rust.html">#rust</a></p></div><h1 id="attributes-in-rust">Attributes in Rust</h1><p>Have you used attributes in the Rust language? Maybe yes, but probably never defined one. Though you don&apos;t have to define attributes in most cases, sometimes new attributes can provide you with a powerful and flexible set of features. I&apos;ve always been interested in learning how to define attributes and exploring their capabilities.</p><p>This post is about defining a new attribute, and see how powerful attributes are.</p><h2 id="environment">Environment</h2><p>In order to define a new attribute, you have to set <code class="inline-code-span">proc-macro</code> in <code class="inline-code-span">Cargo.toml</code>. Add below lines to your <code class="inline-code-span">Cargo.toml</code> file.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">[lib]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-red">proc-macro </span><span class="color-white">= </span><span class="color-gold">true</span></span></span>
</code></pre><p>We&apos;re going to define the attribute in <code class="inline-code-span">lib.rs</code>, and test it in <code class="inline-code-span">main.rs</code>. Make those files in <code class="inline-code-span">/src</code></p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">├ src</span></span>
<span class="code-fence-row"><span class="code-fence-code">│ ├ lib.rs</span></span>
<span class="code-fence-row"><span class="code-fence-code">│ └ main.rs</span></span>
<span class="code-fence-row"><span class="code-fence-code">└ Cargo.toml</span></span>
</code></pre><p>Attribute-related stuffs are defined in the <code class="inline-code-span">proc_macro</code> crate. Add below lines at the top of <code class="inline-code-span">lib.rs</code>.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">extern crate</span><span class="color-white"> proc_macro;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">use </span><span class="color-white">proc_macro::{TokenStream, TokenTree};</span></span></span>
</code></pre><p><a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html">TokenStream</a> and <a href="https://doc.rust-lang.org/proc_macro/enum.TokenTree.html">TokenTree</a> are the main components of a definition of attributes. We&apos;ll look at those in later sections.</p><h2 id="how-an-attribute-looks-like">How an attribute looks like</h2><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">proc_macro_attribute</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">pub fn </span><span class="color-aqua">attribute1</span><span class="color-white">(</span><span class="color-red">attr</span><span class="color-white">: TokenStream, </span><span class="color-red">item</span><span class="color-white">: TokenStream) -&gt; TokenStream {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-gray">// ... func body</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>An attribute is defined like above. <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html">TokenStream</a> is literally a stream of tokens. The function takes tokens as inputs and outputs new tokens. The output tokens replace the original tokens in the code. Interesting point here is that the function is written in Rust. That means you can write a Rust code that directly handles the AST of another Rust code. Sounds very strong, doesn&apos;t it?</p><p>Let&apos;s see how <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html">TokenStream</a> works.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-gray">// lib.rs</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">proc_macro_attribute</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">pub fn </span><span class="color-aqua">attribute1</span><span class="color-white">(</span><span class="color-red">attr</span><span class="color-white">: TokenStream, </span><span class="color-red">item</span><span class="color-white">: TokenStream) -&gt; TokenStream {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-green">attr: </span><span class="color-gold">{attr:?}</span><span class="color-emerald">\n\n</span><span class="color-green">item: </span><span class="color-gold">{item:?}</span><span class="color-white">&quot;);</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    item</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-gray">// main.rs</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">attribute1</span><span class="color-white"> (</span><span class="color-red">a</span><span class="color-white">, </span><span class="color-red">b</span><span class="color-white">)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-green">Hello World!</span><span class="color-white">&quot;);</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>I defined a very simple attribute that prints out the inputs and returns <code class="inline-code-span">item</code> without modifying it. When you add the attribute to the main function and run it, the result is like below. The output of the code is not formatted, but I did it manually for readability.</p><ul><li>The compiler outputs the result when you compile the code, not when you run it. You have to checkout the std-out after running <code class="inline-code-span">cargo build</code>.</li><li><code class="inline-code-span">(a, b)</code> after <code class="inline-code-span">attribute1</code> doesn&apos;t do anything. I added them to demonstrate how the attribute system works. You can add any tokens surrounded by delimiters (&quot;()&quot;, &quot;{}&quot; and &quot;[]&quot;).</li></ul><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">attr: TokenStream [</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Ident { ident: &quot;</span><span class="color-green">a</span><span class="color-white">&quot;, span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">196</span><span class="color-white">..</span><span class="color-gold">197</span><span class="color-white">) },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Punct { ch: &apos;</span><span class="color-green">,</span><span class="color-white">&apos;, spacing: Alone, span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">197</span><span class="color-white">..</span><span class="color-gold">198</span><span class="color-white">) },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Ident { ident: &quot;</span><span class="color-green">b</span><span class="color-white">&quot;, span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">199</span><span class="color-white">..</span><span class="color-gold">200</span><span class="color-white">) }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">item: TokenStream [</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Ident { ident: &quot;</span><span class="color-green">fn</span><span class="color-white">&quot;, span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">203</span><span class="color-white">..</span><span class="color-gold">205</span><span class="color-white">) },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Ident { ident: &quot;</span><span class="color-green">main</span><span class="color-white">&quot;, span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">206</span><span class="color-white">..</span><span class="color-gold">210</span><span class="color-white">) },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Group {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        delimiter: Parenthesis,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        stream: TokenStream [],</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">210</span><span class="color-white">..</span><span class="color-gold">212</span><span class="color-white">)</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Group {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        delimiter: Brace,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        stream: TokenStream [</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            Ident { ident: &quot;</span><span class="color-green">println</span><span class="color-white">&quot;, span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">219</span><span class="color-white">..</span><span class="color-gold">226</span><span class="color-white">) },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            Punct { ch: &apos;</span><span class="color-green">!</span><span class="color-white">&apos;, spacing: Alone, span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">226</span><span class="color-white">..</span><span class="color-gold">227</span><span class="color-white">) },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            Group {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                delimiter: Parenthesis,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                stream: TokenStream [</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                    Literal {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                        kind: Str,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                        symbol: &quot;</span><span class="color-green">Hello World!</span><span class="color-white">&quot;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                        suffix: None,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                        span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">228</span><span class="color-white">..</span><span class="color-gold">242</span><span class="color-white">)</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                ],</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">227</span><span class="color-white">..</span><span class="color-gold">243</span><span class="color-white">)</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            Punct {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                ch: &apos;</span><span class="color-green">;</span><span class="color-white">&apos;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                spacing: Alone,</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">                span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">243</span><span class="color-white">..</span><span class="color-gold">244</span><span class="color-white">)</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        ],</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        span: #</span><span class="color-gold">0 </span><span class="color-emerald">bytes</span><span class="color-white">(</span><span class="color-gold">213</span><span class="color-white">..</span><span class="color-gold">246</span><span class="color-white">)</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">]</span></span></span>
</code></pre><p>The first parameter of the function (<code class="inline-code-span">attr</code>) is the stream of the tokens following the attribute. The second one (<code class="inline-code-span">item</code>) contains all the tokens in the definition of the main function. It even includes keywords like &quot;fn&quot;, and it wraps braces and parenthesises into a <code class="inline-code-span">Group</code> variant.</p><p>All you have to do is to gather information from <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html">TokenStream</a>s and construct new one by modifying them (or from scratch).</p><p>In order to read the tokens, we use <code class="inline-code-span">into_iter</code> method. I&apos;m not sure why, but it doesn&apos;t implement <code class="inline-code-span">iter</code> method. You should clone it if you don&apos;t want to consume it. The method returns an iterator of <a href="https://doc.rust-lang.org/proc_macro/enum.TokenTree.html">TokenTree</a>, which is an enum for Rust tokens. The enum has 4 variants. All the variants share the API for spans (<a href="https://doc.rust-lang.org/proc_macro/enum.TokenTree.html#method.set_span">set_span</a> and <a href="https://doc.rust-lang.org/proc_macro/enum.TokenTree.html#method.span">span</a>). The methods sets or gets span, which is the line number and the column number of the token. It&apos;s useful if you want to output precise error messages. Let&apos;s look at the details of each variant.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">pub enum </span><span class="color-white">TokenTree {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Group(Group),</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Ident(Ident),</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Punct(Punct),</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    Literal(Literal),</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><ul><li><a href="https://doc.rust-lang.org/proc_macro/struct.Group.html">Group</a></li><li><a href="https://doc.rust-lang.org/proc_macro/struct.Ident.html">Ident</a></li><li><a href="https://doc.rust-lang.org/proc_macro/struct.Punct.html">Punct</a></li><li><a href="https://doc.rust-lang.org/proc_macro/struct.Literal.html">Literal</a></li></ul><p>Click the links to see their documents.</p><p><code class="inline-code-span">Group</code> is a <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html">TokenStream</a> surrounded by <code class="inline-code-span">Delimiter</code>s. There are 4 types of <code class="inline-code-span">Delimiter</code>s, which are brackets <code class="inline-code-span">[]</code>, braces <code class="inline-code-span">{}</code>, parenthesis <code class="inline-code-span">()</code>, and none <code class="inline-code-span"> </code>. The last one is used to preserve operator priorities of macro expansions. <code class="inline-code-span">.stream()</code> method returns the contained <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html">TokenStream</a>, without the delimiters. We&apos;ll use it most often.</p><p><code class="inline-code-span">Ident</code> is for an identifier. <code class="inline-code-span">.to_string()</code> turns it into a <code class="inline-code-span">String</code>, and <code class="inline-code-span">new(&amp;str, Span)</code> creates new one.</p><p><code class="inline-code-span">Literal</code> is for a literal, like <code class="inline-code-span">&quot;Hello World!&quot;</code> or <code class="inline-code-span">3.14</code>. <code class="inline-code-span">.to_string()</code> turns it into a <code class="inline-code-span">String</code>, and <code class="inline-code-span">string(&amp;str)</code> creates a new one. There are methods for all kind of literals (<code class="inline-code-span">u32_suffixed</code>, <code class="inline-code-span">f64_unsuffixed</code>, <code class="inline-code-span">character</code>, ...).</p><p><code class="inline-code-span">Punct</code> represents a single-character punctuation. For example, an AddAssign operator (<code class="inline-code-span">+=</code>) is translated to 2 <code class="inline-code-span">Punct</code>s, <code class="inline-code-span">+</code> and <code class="inline-code-span">=</code>. It uses a <a href="https://doc.rust-lang.org/proc_macro/enum.Spacing.html">Spacing</a> enum to differentiate a multi-character token and a sequence of single-character tokens. <code class="inline-code-span">.as_char()</code> turns it into a <code class="inline-code-span">char</code>, and <code class="inline-code-span">.new(char, Spacing)</code> creates new one.</p><h2 id="defining-a-new-attribute">Defining a new attribute</h2><p>Let&apos;s actually define a practical attribute. We&apos;ll implement an attribute for functions. It makes a function print its name when called.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">print_name</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">foo</span><span class="color-white">(</span><span class="color-red">a</span><span class="color-white">: </span><span class="color-violet">u32</span><span class="color-white">, </span><span class="color-red">b</span><span class="color-white">: </span><span class="color-violet">u32</span><span class="color-white">) -&gt; </span><span class="color-violet">u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    a + b</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">foo_with_attribute</span><span class="color-white">(</span><span class="color-red">a</span><span class="color-white">: </span><span class="color-violet">u32</span><span class="color-white">, </span><span class="color-red">b</span><span class="color-white">: </span><span class="color-violet">u32</span><span class="color-white">) -&gt; </span><span class="color-violet">u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-green">Hi! my name is foo</span><span class="color-white">&quot;);</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    a + b</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>Above is our goal. <code class="inline-code-span">foo</code> with <code class="inline-code-span">#[print_name]</code> becomes <code class="inline-code-span">foo_with_attribute</code>. It prints its name at the first line of its body. I won&apos;t change the name of the function in the implementation.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">proc_macro_attribute</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">pub fn </span><span class="color-aqua">print_name</span><span class="color-white">(</span><span class="color-red">attr</span><span class="color-white">: TokenStream, </span><span class="color-red">item</span><span class="color-white">: TokenStream) -&gt; TokenStream {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-violet">let mut</span><span class="color-white"> result = vec![];</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-violet">let mut</span><span class="color-white"> curr_state = State::Init;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-violet">let mut</span><span class="color-white"> func_name = String::new();</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-gray">// todo: construct a new TokenStream</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    result.</span><span class="color-emerald">into_iter</span><span class="color-white">().</span><span class="color-emerald">collect</span><span class="color-white">()</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>I&apos;ll use a finite state machine to read the stream. When a function is found, it adds a <code class="inline-code-span">println!</code> macro at the first line of its body.</p><p>The state machine has 3 states: <code class="inline-code-span">Init</code>, <code class="inline-code-span">FnInit</code> and <code class="inline-code-span">BodyInit</code>.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">for</span><span class="color-white"> token in item.</span><span class="color-emerald">clone</span><span class="color-white">().</span><span class="color-emerald">into_iter</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-violet">match</span><span class="color-white"> curr_state {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        State::Init =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">            <span class="color-gray">// todo</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        State::FnInit =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">            <span class="color-gray">// todo</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        State::BodyInit =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">            <span class="color-gray">// todo</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    result.</span><span class="color-emerald">push</span><span class="color-white">(token);</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>It&apos;s a very simple FSM. I cloned <code class="inline-code-span">item</code> because I want to return the original one if it&apos;s not a function.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">State::Init =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    TokenTree::Ident(i) =&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> i_string = i.</span><span class="color-emerald">to_string</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">        <span class="color-violet">if</span><span class="color-white"> i_string == &quot;</span><span class="color-green">fn</span><span class="color-white">&quot; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            curr_state = State::FnInit;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">        <span class="color-violet">else if</span><span class="color-white"> i_string == &quot;</span><span class="color-green">struct</span><span class="color-white">&quot; || i_string == &quot;</span><span class="color-green">enum</span><span class="color-white">&quot; || i_string == &quot;</span><span class="color-green">union</span><span class="color-white">&quot; || i_string == &quot;</span><span class="color-green">type</span><span class="color-white">&quot; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">            <span class="color-violet">return</span><span class="color-white"> item;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    _ =&gt; {}</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>The first state, <code class="inline-code-span">State::Init</code> waits for the keyword <code class="inline-code-span">fn</code>. If it figures out that it&apos;s not dealing with a function, it returns immediately.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">State::FnInit =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    TokenTree::Ident(i) =&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        func_name = i.</span><span class="color-emerald">to_string</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        curr_state = State::BodyInit;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    _ =&gt; {}</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>The second state reads the name of the function. It assumes that the identifier following <code class="inline-code-span">fn</code> is the name of the function.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-white">State::BodyInit =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    TokenTree::Group(g) =&gt; </span><span class="color-violet">match</span><span class="color-white"> g.</span><span class="color-emerald">delimiter</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        Delimiter::Brace =&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">            <span class="color-violet">let mut</span><span class="color-white"> print_name = TokenStream::from_str(&amp;format!(&quot;</span><span class="color-green">println!(</span><span class="color-emerald">\&quot;</span><span class="color-green">Hi! my name is </span><span class="color-gold">{func_name}</span><span class="color-emerald">\&quot;</span><span class="color-green">);</span><span class="color-white">&quot;)).</span><span class="color-emerald">unwrap</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            print_name.</span><span class="color-emerald">extend</span><span class="color-white">(g.</span><span class="color-emerald">stream</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">            <span class="color-violet">let</span><span class="color-white"> new_group = Group::new(Delimiter::Brace, print_name);</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">            result.</span><span class="color-emerald">push</span><span class="color-white">(TokenTree::Group(new_group));</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">            <span class="color-violet">continue</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        },</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">        _ =&gt; {}  </span><span class="color-gray">// not a function body</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    _ =&gt; {}</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>The last state adds the print statement at the function body. It assumes that a <code class="inline-code-span">Delimiter::Brace</code> appears if and only if it meets the function body. It constructs a new <code class="inline-code-span">Group</code> instance with the print statement, pushes it to <code class="inline-code-span">result</code> and continue the loop immediately, so that it doesn&apos;t push the <code class="inline-code-span">Group</code> twice.</p><h2 id="complete-code">Complete code</h2><ul><li><code class="inline-code-span">lib.rs</code></li></ul><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">extern crate</span><span class="color-white"> proc_macro;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-violet">use </span><span class="color-white">proc_macro::{TokenStream, TokenTree, Delimiter, Group};</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-violet">use </span><span class="color-white">std::str::FromStr;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">proc_macro_attribute</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-violet">pub fn </span><span class="color-aqua">print_name</span><span class="color-white">(</span><span class="color-red">_attr</span><span class="color-white">: TokenStream, </span><span class="color-red">item</span><span class="color-white">: TokenStream) -&gt; TokenStream {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">    <span class="color-violet">let mut</span><span class="color-white"> result = vec![];</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">    <span class="color-violet">let mut</span><span class="color-white"> curr_state = State::Init;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">    <span class="color-violet">let mut</span><span class="color-white"> func_name = String::new();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">    <span class="color-violet">for</span><span class="color-white"> token in item.</span><span class="color-emerald">clone</span><span class="color-white">().</span><span class="color-emerald">into_iter</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">        <span class="color-violet">match</span><span class="color-white"> curr_state {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">            State::Init =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-white">                TokenTree::Ident(i) =&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code">                    <span class="color-violet">let</span><span class="color-white"> i_string = i.</span><span class="color-emerald">to_string</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code">                    <span class="color-violet">if</span><span class="color-white"> i_string == &quot;</span><span class="color-green">fn</span><span class="color-white">&quot; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code"><span class="color-white">                        curr_state = State::FnInit;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code"><span class="color-white">                    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code">                    <span class="color-violet">else if</span><span class="color-white"> i_string == &quot;</span><span class="color-green">struct</span><span class="color-white">&quot; || i_string == &quot;</span><span class="color-green">enum</span><span class="color-white">&quot; || i_string == &quot;</span><span class="color-green">union</span><span class="color-white">&quot; || i_string == &quot;</span><span class="color-green">type</span><span class="color-white">&quot; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">23</span><span class="code-fence-code">                        <span class="color-violet">return</span><span class="color-white"> item;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">24</span><span class="code-fence-code"><span class="color-white">                    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">25</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">26</span><span class="code-fence-code"><span class="color-white">                }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">27</span><span class="code-fence-code"><span class="color-white">                _ =&gt; {}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">28</span><span class="code-fence-code"><span class="color-white">            }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">29</span><span class="code-fence-code"><span class="color-white">            State::FnInit =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">30</span><span class="code-fence-code"><span class="color-white">                TokenTree::Ident(i) =&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">31</span><span class="code-fence-code"><span class="color-white">                    func_name = i.</span><span class="color-emerald">to_string</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">32</span><span class="code-fence-code"><span class="color-white">                    curr_state = State::BodyInit;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">33</span><span class="code-fence-code"><span class="color-white">                }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">34</span><span class="code-fence-code"><span class="color-white">                _ =&gt; {}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">35</span><span class="code-fence-code"><span class="color-white">            }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">36</span><span class="code-fence-code"><span class="color-white">            State::BodyInit =&gt; </span><span class="color-violet">match </span><span class="color-white">&amp;token {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">37</span><span class="code-fence-code"><span class="color-white">                TokenTree::Group(g) =&gt; </span><span class="color-violet">match</span><span class="color-white"> g.</span><span class="color-emerald">delimiter</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">38</span><span class="code-fence-code"><span class="color-white">                    Delimiter::Brace =&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">39</span><span class="code-fence-code">                        <span class="color-violet">let mut</span><span class="color-white"> print_name = TokenStream::from_str(&amp;format!(&quot;</span><span class="color-green">println!(</span><span class="color-emerald">\&quot;</span><span class="color-green">Hi! my name is </span><span class="color-gold">{func_name}</span><span class="color-emerald">\&quot;</span><span class="color-green">);</span><span class="color-white">&quot;)).</span><span class="color-emerald">unwrap</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">40</span><span class="code-fence-code"><span class="color-white">                        print_name.</span><span class="color-emerald">extend</span><span class="color-white">(g.</span><span class="color-emerald">stream</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">41</span><span class="code-fence-code">                        <span class="color-violet">let</span><span class="color-white"> new_group = Group::new(Delimiter::Brace, print_name);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">42</span><span class="code-fence-code"><span class="color-white">                        result.</span><span class="color-emerald">push</span><span class="color-white">(TokenTree::Group(new_group));</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">43</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">44</span><span class="code-fence-code">                        <span class="color-violet">continue</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">45</span><span class="code-fence-code"><span class="color-white">                    },</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">46</span><span class="code-fence-code"><span class="color-white">                    _ =&gt; {}  </span><span class="color-gray">// not a function body</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">47</span><span class="code-fence-code"><span class="color-white">                }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">48</span><span class="code-fence-code"><span class="color-white">                _ =&gt; {}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">49</span><span class="code-fence-code"><span class="color-white">            }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">50</span><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">51</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">52</span><span class="code-fence-code"><span class="color-white">        result.</span><span class="color-emerald">push</span><span class="color-white">(token);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">53</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">54</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">55</span><span class="code-fence-code"><span class="color-white">    result.</span><span class="color-emerald">into_iter</span><span class="color-white">().</span><span class="color-emerald">collect</span><span class="color-white">()</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">56</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">57</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">58</span><span class="code-fence-code"><span class="color-violet">enum </span><span class="color-white">State {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">59</span><span class="code-fence-code"><span class="color-white">    Init,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">60</span><span class="code-fence-code"><span class="color-white">    FnInit,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">61</span><span class="code-fence-code"><span class="color-white">    BodyInit</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">62</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(13)" class="copy-fenced-code">Copy</button></pre><ul><li><code class="inline-code-span">main.rs</code></li></ul><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">use </span><span class="color-white">attr_test::*;  </span><span class="color-gray">// name of the library you defined</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">print_name</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">foo</span><span class="color-white">(</span><span class="color-red">a</span><span class="color-white">: </span><span class="color-violet">u32</span><span class="color-white">, </span><span class="color-red">b</span><span class="color-white">: </span><span class="color-violet">u32</span><span class="color-white">) -&gt; </span><span class="color-violet">u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    a + b - </span><span class="color-gold">1</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-emerald">foo</span><span class="color-white">(</span><span class="color-gold">100</span><span class="color-white">, </span><span class="color-gold">200</span><span class="color-white">);</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><script>/*<![CDATA[*/
const fenced_code_block_contents = ["", "", "", "", "", "", "", "", "", "", "", "", "", "extern crate proc_macro;\nuse proc_macro::{TokenStream, TokenTree, Delimiter, Group};\nuse std::str::FromStr;\n\n#[proc_macro_attribute]\npub fn print_name(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    let mut result = vec![];\n    let mut curr_state = State::Init;\n    let mut func_name = String::new();\n\n    for token in item.clone().into_iter() {\n\n        match curr_state {\n            State::Init => match &token {\n                TokenTree::Ident(i) => {\n                    let i_string = i.to_string();\n\n                    if i_string == \"fn\" {\n                        curr_state = State::FnInit;\n                    }\n\n                    else if i_string == \"struct\" || i_string == \"enum\" || i_string == \"union\" || i_string == \"type\" {\n                        return item;\n                    }\n\n                }\n                _ => {}\n            }\n            State::FnInit => match &token {\n                TokenTree::Ident(i) => {\n                    func_name = i.to_string();\n                    curr_state = State::BodyInit;\n                }\n                _ => {}\n            }\n            State::BodyInit => match &token {\n                TokenTree::Group(g) => match g.delimiter() {\n                    Delimiter::Brace => {\n                        let mut print_name = TokenStream::from_str(&format!(\"println!(\\\"Hi! my name is {func_name}\\\");\")).unwrap();\n                        print_name.extend(g.stream());\n                        let new_group = Group::new(Delimiter::Brace, print_name);\n                        result.push(TokenTree::Group(new_group));\n\n                        continue;\n                    },\n                    _ => {}  // not a function body\n                }\n                _ => {}\n            }\n        }\n\n        result.push(token);\n    }\n\n    result.into_iter().collect()\n}\n\nenum State {\n    Init,\n    FnInit,\n    BodyInit\n}"];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
</body>

</html>