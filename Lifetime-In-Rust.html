<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    
    <title>Lifetime-In-Rust</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="Articles.html">Articles</a> <a href="Tags.html">Tags</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9776;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p></p><div id="settingsmenu"><table><thead><tr><th colspan="2"><div class="align-right"> <span class="size-giant"><a id="settingsclosebutton">&#10006;</a></span></div></th></tr></thead><tbody><tr><td><div class="align-right">Theme:</div></td><td><div class="align-left"><a id="changethemebutton">Set Light Theme</a></div></td></tr><tr><td><div class="align-right">Horizontal Padding:</div></td><td><div class="align-left"><a id="growhorizontalbutton">Grow</a> <a id="shrinkhorizontalbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Font Size:</div></td><td><div class="align-left"><a id="growfontbutton">Grow</a> <a id="shrinkfontbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Settings:</div></td><td><div class="align-left"><a id="savesettingsbutton">Save All</a> <a id="discardsettingsbutton">Discard All</a></div></td></tr></tbody></table></div></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<div class="align-right"><p>Last Updated: 31.January.2023</p><p>Tags: <a href="tag-rust.html">#rust</a></p></div><h1 id="how-lifetimes-work-in-rust">How lifetimes work in Rust</h1><p>Lifetime is one of the most important concept in the Rust world. It guarantees that a pointer is always pointing to a valid memory. The safety guarantee it gives makes the language very powerful, but it&apos;s difficulty make young programmers hesitate to become Rustacean. I was one among them. I&apos;ve been using this language for years (all the frameworks for this blog is written in Rust), but still not sure how lifetimes work. This blog post is a complete guide for the Rust lifetimes, for myself and others.</p><blockquote>Most of this post is a summary of the <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">official Rust book</a>. It helps me understand the concept by summarizing it. If you also want to understand the concept, you should read the book, not this article. </blockquote><h2 id="what-is-a-lifetime">What is a lifetime?</h2><p><span class="size-giant">Lifetime is a part of the type system.</span> Every reference in Rust has a lifetime telling how long does the reference live. That means <code class="inline-code-span">&amp;u32</code> that lives long and <code class="inline-code-span">&amp;u32</code> that lives short are different types. If a struct has references as it&apos;s field, the struct also has a lifetime. Structs with different lifetimes are regarded as different types.</p><p>The biggest role of lifetimes is preventing dangling references. Let&apos;s look at an example below.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> r;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> x = </span><span class="color-gold">5</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">        r = &amp;x;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-green">r: </span><span class="color-gold">{}</span><span class="color-white">&quot;, r);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(0)" class="copy-fenced-code">Copy</button></pre><p>In the example, <code class="inline-code-span">x</code> goes out of scope at line 7, and <code class="inline-code-span">r</code> tries to read the value of <code class="inline-code-span">x</code> at line 9. It seems obvious that the program is wrong, but how does the compiler know that? The compiler checks the <em>lifetime</em> of each value, and makes sure that the original value lives longer than it&apos;s references. It&apos;s illustrated below.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> r;                </span><span class="color-gray">// ---------+-- &apos;a</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">                          <span class="color-gray">//          |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    {                     </span><span class="color-gray">//          |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> x = </span><span class="color-gold">5</span><span class="color-white">;        </span><span class="color-gray">// -+-- &apos;b  |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">        r = &amp;x;           </span><span class="color-gray">//  |       |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    }                     </span><span class="color-gray">// -+       |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">                          <span class="color-gray">//          |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-green">r: </span><span class="color-gold">{}</span><span class="color-white">&quot;, r); </span><span class="color-gray">//          |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">}                         </span><span class="color-gray">// ---------+</span></span></span>
</code><button onclick="copy_code_to_clipboard(1)" class="copy-fenced-code">Copy</button></pre><p><code class="inline-code-span">&apos;a</code> is the lifetime of <code class="inline-code-span">r</code>, and <code class="inline-code-span">&apos;b</code> is of <code class="inline-code-span">x</code>. A lifetime starts when a value is initialized, and ends when it&apos;s dropped. Since <code class="inline-code-span">r</code> is referencing <code class="inline-code-span">x</code>, the compiler wants the lifetime of <code class="inline-code-span">x</code> to be longer than <code class="inline-code-span">r</code>. The compiler refuses the above code because <code class="inline-code-span">x</code> doesn&apos;t <em>live long enough</em>.</p><p>We call it <em>Borrow-Checker</em>. It checks all the <em>borrows</em> (references) live long enough, so that there&apos;s no dangling pointers.</p><p>That&apos;s it. It&apos;s how the Rust compiler utilizes lifetimes. It&apos;s a very simple concept, but it gets complicated when the code becomes longer.</p><h2 id="lifetimes-of-function-parameters">Lifetimes of function parameters</h2><p>Let&apos;s define a function. It takes two references as it&apos;s input, and returns the bigger one.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">big</span><span class="color-white">(</span><span class="color-red">m</span><span class="color-white">: &amp;</span><span class="color-violet">u32</span><span class="color-white">, </span><span class="color-red">n</span><span class="color-white">: &amp;</span><span class="color-violet">u32</span><span class="color-white">) -&gt; &amp;</span><span class="color-violet">u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">if </span><span class="color-white">*m &lt; *n { n } </span><span class="color-violet">else </span><span class="color-white">{ m }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(2)" class="copy-fenced-code">Copy</button></pre><p>The code is straightforward, but the compiler doesn&apos;t allow it. Below is the error message.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0106]: missing lifetime specifier</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:1:29</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">1 | fn big(m: &amp;u32, n: &amp;u32) -&gt; &amp;u32 {</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                             ^ expected lifetime parameter</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  = help: this function&apos;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `m` or `n`</span></span>
</code></pre><p>The return value of the function is either <code class="inline-code-span">m</code> or <code class="inline-code-span">n</code>, which might have different lifetimes. If the compiler doesn&apos;t know the lifetime, the borrow-checker will not work! I&apos;ll show you a counter-example.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> x = </span><span class="color-emerald">input</span><span class="color-white">();       </span><span class="color-gray">// --------+--&apos;a</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> z;                 </span><span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    {                      </span><span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> y = </span><span class="color-emerald">input</span><span class="color-white">();   </span><span class="color-gray">// -+--&apos;b  |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">                           <span class="color-gray">//  |      |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">        z = </span><span class="color-emerald">big</span><span class="color-white">(&amp;x, &amp;y);   </span><span class="color-gray">//  |      |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    }                      </span><span class="color-gray">// -+      |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">                           <span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-green">z: </span><span class="color-gold">{}</span><span class="color-white">&quot;, z);  </span><span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">}                          </span><span class="color-gray">// --------+</span></span></span>
</code><button onclick="copy_code_to_clipboard(4)" class="copy-fenced-code">Copy</button></pre><p>If <code class="inline-code-span">big</code> returns <code class="inline-code-span">&amp;y</code>, it&apos;s dropped before <code class="inline-code-span">println!</code> is called, which is problematic. If <code class="inline-code-span">big</code> returns <code class="inline-code-span">&amp;x</code>, there&apos;s no problem. But it&apos;s impossible to know whether <code class="inline-code-span">&amp;x</code> or <code class="inline-code-span">&amp;y</code> will be chosen at compile-time. So the compiler refueses this possibly-problematic code. How do we fix this? We first have to add lifetime annotations to the function declaration, like below.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">big</span><span class="color-white">&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">, </span><span class="color-violet">&apos;b</span><span class="color-white">&gt;(</span><span class="color-red">m</span><span class="color-white">: &amp;</span><span class="color-violet">&apos;a u32</span><span class="color-white">, </span><span class="color-red">n</span><span class="color-white">: &amp;</span><span class="color-violet">&apos;b u32</span><span class="color-white">) -&gt; &amp;</span><span class="color-violet">&apos;a u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">if </span><span class="color-white">*m &lt; *n { n } </span><span class="color-violet">else </span><span class="color-white">{ m }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(5)" class="copy-fenced-code">Copy</button></pre><p>It&apos;s our first attempt. I gave different lifetimes to <code class="inline-code-span">m</code> and <code class="inline-code-span">n</code> because they might have different ones. But in that case, we cannot annotate the lifetime of the return value.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0623]: lifetime mismatch</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:2:18</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">1 | fn big&lt;&apos;a, &apos;b&gt;(m: &amp;&apos;a u32, n: &amp;&apos;b u32) -&gt; &amp;&apos;a u32 {</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                               -------     -------</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                               |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                               this parameter and the return type are declared with different lifetimes...</span></span>
<span class="code-fence-row"><span class="code-fence-code">2 |     if *m &lt; *n { n } else { m }</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                  ^ ...but data from `n` is returned here</span></span>
</code></pre><p>What the compiler is complaining is that, the type of the return value should be <code class="inline-code-span">&amp;&apos;a u32</code>, but line 2 returns <code class="inline-code-span">&amp;&apos;b u32</code>. How do we fix it? Let&apos;s give it another try.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">big</span><span class="color-white">&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt;(</span><span class="color-red">m</span><span class="color-white">: &amp;</span><span class="color-violet">&apos;a u32</span><span class="color-white">, </span><span class="color-red">n</span><span class="color-white">: &amp;</span><span class="color-violet">&apos;a u32</span><span class="color-white">) -&gt; &amp;</span><span class="color-violet">&apos;a u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">if </span><span class="color-white">*m &lt; *n { n } </span><span class="color-violet">else </span><span class="color-white">{ m }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(7)" class="copy-fenced-code">Copy</button></pre><p>We gave the same lifetime to <code class="inline-code-span">m</code> and <code class="inline-code-span">n</code>. Though it compiles, it sounds a bit strange. In most cases, <code class="inline-code-span">m</code> and <code class="inline-code-span">n</code> would have different lifetimes, but why are we giving the same lifetimes to them? That&apos;s because we&apos;re giving long enough lifetimes, not an exact lifetime. So the lifetime annotation means <u><code class="inline-code-span">m</code> is valid in <code class="inline-code-span">&apos;a</code>, <code class="inline-code-span">n</code> is valid in <code class="inline-code-span">&apos;a</code>, and the return value is valid in <code class="inline-code-span">&apos;a</code>.</u></p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> x = </span><span class="color-emerald">input</span><span class="color-white">();       </span><span class="color-gray">// --------+--&apos;a</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> z;                 </span><span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    {                      </span><span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> y = </span><span class="color-emerald">input</span><span class="color-white">();   </span><span class="color-gray">// -+--&apos;b  |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">                           <span class="color-gray">//  |      |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">        z = </span><span class="color-emerald">big</span><span class="color-white">(&amp;x, &amp;y);   </span><span class="color-gray">//  |      |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    }                      </span><span class="color-gray">// -+      |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">                           <span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-green">z: </span><span class="color-gold">{}</span><span class="color-white">&quot;, z);  </span><span class="color-gray">//         |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">}                          </span><span class="color-gray">// --------+</span></span></span>
</code><button onclick="copy_code_to_clipboard(8)" class="copy-fenced-code">Copy</button></pre><p>What&apos;s the lifetime of the input values of <code class="inline-code-span">big</code> in this code? It must be either <code class="inline-code-span">&apos;a</code> or <code class="inline-code-span">&apos;b</code>. If it&apos;re <code class="inline-code-span">&apos;a</code>, it doesn&apos;t make sense because <code class="inline-code-span">y</code> dies before <code class="inline-code-span">&apos;a</code> finishes. If it&apos;re <code class="inline-code-span">&apos;b</code>, it makes sense because both are valid in <code class="inline-code-span">&apos;b</code>. So the compiler gives <code class="inline-code-span">&apos;b</code> to the return value of <code class="inline-code-span">big</code>. It tells that the return value is valid in <code class="inline-code-span">&apos;b</code>, but it&apos;d be dangerous to use the value after <code class="inline-code-span">&apos;b</code>. That&apos;s why the compiler doesn&apos;t let us assign <code class="inline-code-span">big</code> to <code class="inline-code-span">z</code>.</p><h3 id="lifetimes-of-structs">Lifetimes of structs</h3><p>If a struct holds references, the struct needs a lifetime annotation.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">struct </span><span class="color-white">RefInt&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-red">i</span><span class="color-white">: &amp;</span><span class="color-violet">&apos;a u32</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> x = </span><span class="color-gold">3</span><span class="color-white">;                </span><span class="color-gray">// ---------+--&apos;b</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> s = RefInt { i: &amp;x }; </span><span class="color-gray">// -+--&apos;c   |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">                              <span class="color-gray">//  |       |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-gold">{}</span><span class="color-white">&quot;, s.i);      </span><span class="color-gray">// -+-------+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(9)" class="copy-fenced-code">Copy</button></pre><p>It compiles! The compiler has to make sure that <code class="inline-code-span">RefInt</code> never owns an uninitialized pointer. So the original value of <code class="inline-code-span">i</code> must live longer than the instance of <code class="inline-code-span">RefInt</code>. In the code, the original value <code class="inline-code-span">x</code> lives longer than <code class="inline-code-span">s</code> and the code compiles.</p><p>The lifetime annotations of structs are read in this way: <u><code class="inline-code-span">i</code> is valid in <code class="inline-code-span">&apos;a</code> and the instance is valid in <code class="inline-code-span">&apos;a</code>.</u> In the code, <code class="inline-code-span">i</code> is valid in <code class="inline-code-span">&apos;b</code> and <code class="inline-code-span">s</code> is valid in <code class="inline-code-span">&apos;b</code>. They both are valid in <code class="inline-code-span">&apos;c</code>, so the compiler accepts our code.</p><h2 id="lifetime-ellision">Lifetime ellision</h2><p>In earlier versions of Rust, we had to specify the lifetime of every reference. That sounds very cumbersome, doesn&apos;t it? The compiler tries to infer the lifetime with a few rules. Though it only has 3 rules, more rules will be added as the language evolves. Below are the rules.</p><ol type="1"><li>The compiler assigns lifetimes to each reference.<ul><li><code class="inline-code-span">fn foo(n: &amp;u32)</code> -&gt; <code class="inline-code-span">fn foo&lt;&apos;a&gt;(n: &amp;&apos;a u32)</code></li><li><code class="inline-code-span">fn foo(n: &amp;u32, m: &amp;u32)</code> -&gt; <code class="inline-code-span">fn foo&lt;&apos;a, &apos;b&gt;(n: &amp;&apos;a u32, m: &amp;&apos;b u32)</code></li></ul></li><li>If there&apos;s only one lifetime parameter in the input, all the outputs have that lifetime.<ul><li><code class="inline-code-span">fn foo&lt;&apos;a&gt;(n: &amp;&apos;a u32) -&gt; &amp;u32</code> -&gt; <code class="inline-code-span">fn foo&lt;&apos;a&gt;(n: &amp;&apos;a u32) -&gt; &amp;&apos;a u32</code></li></ul></li><li>If a method has a reference to <code class="inline-code-span">self</code>, (ex: <code class="inline-code-span">&amp;self</code>, <code class="inline-code-span">&amp;mut self</code>), the lifetime of <code class="inline-code-span">self</code> is assigned to all the output lifetime parameters.</li></ol><p>The second and the third ones are the most important. They allow us to omit lifetime parameters in most cases. Let&apos;s look at why those rules make sense.</p><p>When a function returns a reference, the reference has to be valid at the moment it&apos;s returned. But all the values owned by the functions are dropped when the function returns. That means the return value has to reference something that&apos;s not owned by the function. What can be such thing? Let&apos;s look at some examples.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">func1</span><span class="color-white">(</span><span class="color-red">n</span><span class="color-white">: &amp;</span><span class="color-violet">u32</span><span class="color-white">) -&gt; &amp;</span><span class="color-violet">u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">    n</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">func2</span><span class="color-white">&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt;() -&gt; &amp;</span><span class="color-violet">&apos;a u32 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> x = </span><span class="color-gold">3</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    &amp;x</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(10)" class="copy-fenced-code">Copy</button></pre><p><code class="inline-code-span">func1</code> compiles but <code class="inline-code-span">func2</code> does not. <code class="inline-code-span">n</code> and the return value of <code class="inline-code-span">func1</code> have the same lifetime as you see in its body. But <code class="inline-code-span">func2</code> raises an error like below.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0515]: cannot return reference to local variable `x`</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:7:5</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">7 |     &amp;x</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ^^ returns a reference to data owned by the current function</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error: aborting due to previous error</span></span>
</code></pre><p>The value <code class="inline-code-span">x</code> is dropped at line 8, so the reference to <code class="inline-code-span">x</code> cannot be used by others.</p><p>Are there execptions for the rule? Let&apos;s make a function that returns a reference that&apos;s not an input.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">func3</span><span class="color-white">(_: &amp;</span><span class="color-violet">str</span><span class="color-white">) -&gt; (&amp;</span><span class="color-violet">str</span><span class="color-white">, String) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> x = String::from(&quot;</span><span class="color-green">abc</span><span class="color-white">&quot;);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    (&amp;x, x)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(12)" class="copy-fenced-code">Copy</button></pre><p>I wanted to return a value created in the function. If the value is not dropped at the end of the function, reference must be valid! In order to prevent from being dropped, I have to return the value (moving it&apos;s ownership). Does it work? Well... look at the error messages below.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0515]: cannot return value referencing local variable `x`</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:4:5</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">4 |     (&amp;x, x)</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ^--^^^^</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ||</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     |`x` is borrowed here</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     returns a value referencing data owned by the current function</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error[E0505]: cannot move out of `x` because it is borrowed</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:4:10</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">1 | fn func3(_: &amp;str) -&gt; (&amp;str, String) {</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |             - let&apos;s call the lifetime of this reference `&apos;1`</span></span>
<span class="code-fence-row"><span class="code-fence-code">...</span></span>
<span class="code-fence-row"><span class="code-fence-code">4 |     (&amp;x, x)</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     -----^-</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ||   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ||   move out of `x` occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     |borrow of `x` occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     returning this value requires that `x` is borrowed for `&apos;1`</span></span>
</code></pre><p>The compiler tells me that what I&apos;m trying to do is impossible. When moving <code class="inline-code-span">x</code> out of the function, the reference is invalidated. What if we change the shape of it&apos;s output?</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">func4</span><span class="color-white">(_: &amp;</span><span class="color-violet">str</span><span class="color-white">) -&gt; (String, &amp;</span><span class="color-violet">str</span><span class="color-white">) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> x = String::from(&quot;</span><span class="color-green">abc</span><span class="color-white">&quot;);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    (x, &amp;x)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(14)" class="copy-fenced-code">Copy</button></pre><p>I hope moving <code class="inline-code-span">x</code> doesn&apos;t validate <code class="inline-code-span">&amp;x</code> in this code. Does it?</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0515]: cannot return value referencing local variable `x`</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:4:5</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">4 |     (x, &amp;x)</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ^^^^--^</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     |   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     |   `x` is borrowed here</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     returns a value referencing data owned by the current function</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error[E0382]: borrow of moved value: `x`</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:4:9</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">2 |     let x = String::from(&quot;abc&quot;);</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |         - move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait</span></span>
<span class="code-fence-row"><span class="code-fence-code">3 | </span></span>
<span class="code-fence-row"><span class="code-fence-code">4 |     (x, &amp;x)</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |      -  ^^ value borrowed here after move</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |      |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |      value moved here</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error: aborting due to 2 previous errors</span></span>
</code></pre><p>It doesn&apos;t even let me reference <code class="inline-code-span">x</code> because <code class="inline-code-span">x</code> is moved before referenced. Well I guess it&apos;s impossible to return such reference.</p><h3 id="more-examples">More Examples</h3><p>Let&apos;s look at more complicated example. I&apos;ll define a struct that holds a reference to itself. Then I&apos;ll try to create a dangling pointer by messing up with the struct. Let&apos;s hack!</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">struct </span><span class="color-white">RefSelf&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-red">vec</span><span class="color-white">: Vec&lt;</span><span class="color-violet">u32</span><span class="color-white">&gt;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-red">refs</span><span class="color-white">: Vec&lt;&amp;</span><span class="color-violet">&apos;a u32</span><span class="color-white">&gt;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(16)" class="copy-fenced-code">Copy</button></pre><p>Well, it compiles! Now, let&apos;s make <code class="inline-code-span">refs</code> reference the values of <code class="inline-code-span">vec</code>.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt; RefSelf&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">pub fn </span><span class="color-aqua">new</span><span class="color-white">() -&gt; </span><span class="color-violet">Self </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> vec = vec![</span><span class="color-gold">0</span><span class="color-white">; </span><span class="color-gold">10</span><span class="color-white">];</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> refs = vec![&amp;vec[</span><span class="color-gold">0</span><span class="color-white">]];</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">        RefSelf { vec, refs }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(17)" class="copy-fenced-code">Copy</button></pre><p>It&apos;s the most naive way I can think of. It fails, saying that it cannot move out of <code class="inline-code-span">vec</code> because it&apos;s borrowed. It&apos;s what we&apos;ve seen in the error messages of <code class="inline-code-span">func3</code>. Let&apos;s try more deliberate way.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt; RefSelf&lt;</span><span class="color-violet">&apos;a</span><span class="color-white">&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">pub fn </span><span class="color-aqua">new</span><span class="color-white">() -&gt; </span><span class="color-violet">Self </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> vec = vec![</span><span class="color-gold">0</span><span class="color-white">; </span><span class="color-gold">10</span><span class="color-white">];</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> refs = vec![];</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">        RefSelf { vec, refs }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">    <span class="color-violet">pub fn </span><span class="color-aqua">add</span><span class="color-white">(&amp;</span><span class="color-violet">&apos;a mut </span><span class="color-red">self</span><span class="color-white">) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.refs.</span><span class="color-emerald">push</span><span class="color-white">(&amp;</span><span class="color-red">self</span><span class="color-white">.vec[</span><span class="color-gold">0</span><span class="color-white">]);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">    <span class="color-violet">pub fn </span><span class="color-aqua">clear</span><span class="color-white">(&amp;</span><span class="color-violet">&apos;a mut </span><span class="color-red">self</span><span class="color-white">) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.vec.</span><span class="color-emerald">clear</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(18)" class="copy-fenced-code">Copy</button></pre><p>It compiles! My plan is to print <code class="inline-code-span">&amp;self.vec[0]</code> after clearing <code class="inline-code-span">self.vec</code>. If it compiles, it&apos;d print an uninitialized value (a value of a freed memory).</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let mut</span><span class="color-white"> refself = RefSelf::new();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">    refself.</span><span class="color-emerald">add</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-gold">{}</span><span class="color-white">&quot;, refself.refs[</span><span class="color-gold">0</span><span class="color-white">]);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">    refself.</span><span class="color-emerald">clear</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-gold">{}</span><span class="color-white">&quot;, refself.refs[</span><span class="color-gold">0</span><span class="color-white">]);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(19)" class="copy-fenced-code">Copy</button></pre><p>Does it successfully destroys the borrow checker? Look at the result below.</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0502]: cannot borrow `refself.refs` as immutable because it is also borrowed as mutable</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:4:20</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">3 |     refself.add();</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ------- mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">4 |     println!(&quot;{}&quot;, refself.refs[0]);</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    ^^^^^^^^^^^^</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    immutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    mutable borrow later used here</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error[E0499]: cannot borrow `refself` as mutable more than once at a time</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:5:5</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">3 |     refself.add();</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ------- first mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">4 |     println!(&quot;{}&quot;, refself.refs[0]);</span></span>
<span class="code-fence-row"><span class="code-fence-code">5 |     refself.clear();</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ^^^^^^^</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     second mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     first borrow later used here</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error[E0502]: cannot borrow `refself.refs` as immutable because it is also borrowed as mutable</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; main.rs:6:20</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">3 |     refself.add();</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |     ------- mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">...</span></span>
<span class="code-fence-row"><span class="code-fence-code">6 |     println!(&quot;{}&quot;, refself.refs[0]);</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    ^^^^^^^^^^^^</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    |</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    immutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                    mutable borrow later used here</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error: aborting due to 3 previous errors</span></span>
</code></pre><p>What&apos;s going on? When <code class="inline-code-span">refself.add</code> is called, it asks <code class="inline-code-span">&amp;&apos;a mut self</code> as an input. After that, <code class="inline-code-span">refself</code> holds the mutable reference of itself. While the mutable reference exists, no one can make a reference of <code class="inline-code-span">refself</code>. It&apos;s very important rule: a mutable reference must be the only reference. The mutable reference&apos;s lifetime is <code class="inline-code-span">&apos;a</code>, which is the lifetime of <code class="inline-code-span">refself</code>. So any reference to <code class="inline-code-span">refself</code> after line 3 is an error.</p><p>What if we change the declaration of the methods?</p><ul><li><code class="inline-code-span">pub fn add(&amp;&apos;a mut self)</code> -&gt; <code class="inline-code-span">pub fn add(&amp;mut self)</code></li><li><code class="inline-code-span">pub fn clear(&amp;&apos;a mut self)</code> -&gt; <code class="inline-code-span">pub fn clear(&amp;mut self)</code></li></ul><p>It lets the compiler choose the lifetime of <code class="inline-code-span">&amp;mut self</code> more flexibly. Can I break the borrow checker this time? No...</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0495]: cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements</span></span>
<span class="code-fence-row"><span class="code-fence-code">  --&gt; main.rs:24:25</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">24 |         self.refs.push(&amp;self.vec[0]);</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |                         ^^^^^^^^^^^</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 23:5...</span></span>
<span class="code-fence-row"><span class="code-fence-code">  --&gt; main.rs:23:5</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">23 | /     pub fn add(&amp;mut self) {</span></span>
<span class="code-fence-row"><span class="code-fence-code">24 | |         self.refs.push(&amp;self.vec[0]);</span></span>
<span class="code-fence-row"><span class="code-fence-code">25 | |     }</span></span>
<span class="code-fence-row"><span class="code-fence-code">   | |_____^</span></span>
<span class="code-fence-row"><span class="code-fence-code">note: ...so that reference does not outlive borrowed content</span></span>
<span class="code-fence-row"><span class="code-fence-code">  --&gt; main.rs:24:25</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">24 |         self.refs.push(&amp;self.vec[0]);</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |                         ^^^^^^^^</span></span>
<span class="code-fence-row"><span class="code-fence-code">note: but, the lifetime must be valid for the lifetime &apos;a as defined on the impl at 14:6...</span></span>
<span class="code-fence-row"><span class="code-fence-code">  --&gt; main.rs:14:6</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">14 | impl&lt;&apos;a&gt; RefSelf&lt;&apos;a&gt; {</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |      ^^</span></span>
<span class="code-fence-row"><span class="code-fence-code">note: ...so that reference does not outlive borrowed content</span></span>
<span class="code-fence-row"><span class="code-fence-code">  --&gt; main.rs:24:24</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">24 |         self.refs.push(&amp;self.vec[0]);</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |                        ^^^^^^^^^^^^</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error: aborting due to previous error</span></span>
</code></pre><p>We&apos;re seeing a brand-new error type this time. In this case, the compiler gives a lifetime <code class="inline-code-span">&apos;b</code> to <code class="inline-code-span">&amp;mut self</code> of <code class="inline-code-span">fn add(&amp;mut self)</code> (rule 1). The second error message is telling us that <code class="inline-code-span">&amp;self.vec[0]</code> cannot outlive <code class="inline-code-span">&apos;b</code>, because that&apos;s the lifetime of <code class="inline-code-span">self</code>. And the forth error message is telling us that <code class="inline-code-span">&amp;self.vec[0]</code> must be valid for <code class="inline-code-span">&apos;a</code>, because that&apos;s the lifetime of <code class="inline-code-span">self</code>. Since the compiler doesn&apos;t know that <code class="inline-code-span">&apos;a</code> and <code class="inline-code-span">&apos;b</code> are same, it refuses our code.</p><h4 id="another-example">Another example</h4><p>It&apos;s so fun to messing up with the lifetime checker, isn&apos;t it? I&apos;ll show you another Rust code.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">foo</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> a = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> b = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">bar</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> c = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> d = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-gold">{:?}</span><span class="color-white">&quot;, c);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">baz</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> e = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> f = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-gold">{:?}</span><span class="color-white">&quot;, f);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(22)" class="copy-fenced-code">Copy</button></pre><p>We&apos;ve taught that there can exist only one mutable reference of a value. So, it seems that the lifetime checker will refuse all the 3 functions above... does it?</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0499]: cannot borrow `v` as mutable more than once at a time</span></span>
<span class="code-fence-row"><span class="code-fence-code"> --&gt; src\main.rs:7:13</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |</span></span>
<span class="code-fence-row"><span class="code-fence-code">6 |     let c = &amp;mut v;</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |             ------ first mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">7 |     let d = &amp;mut v;</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |             ^^^^^^ second mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">8 |     println!(&quot;{:?}&quot;, c);</span></span>
<span class="code-fence-row"><span class="code-fence-code">  |                      - first borrow later used here</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">For more information about this error, try `rustc --explain E0499`.</span></span>
</code></pre><p>It only refuses <code class="inline-code-span">bar</code>. That&apos;s because <em>lifetime</em> is a very flexible concept. <code class="inline-code-span">a</code> and <code class="inline-code-span">e</code> are not used at all. So their lifetime ends as soon as they&apos;re declared. In those cases, their lifetime do not overlap with <code class="inline-code-span">b</code> and <code class="inline-code-span">f</code>&apos;s lifetime. So it&apos;s fine to create another mutable reference. But in <code class="inline-code-span">c</code>&apos;s case, it&apos;s lifetime ends at line 9, which is after <code class="inline-code-span">d</code> is declared.</p><p>See how it&apos;s visualized.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">foo</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> a = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;  </span><span class="color-gray">// ---&apos;a</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> b = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;  </span><span class="color-gray">// ---&apos;b</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">bar</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> c = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;       </span><span class="color-gray">// --------+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> d = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;       </span><span class="color-gray">// ---&apos;d   |    -&gt; Oops!</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-gold">{:?}</span><span class="color-white">&quot;, c);  </span><span class="color-gray">// --------+-&apos;c</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">baz</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> e = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;       </span><span class="color-gray">// ---&apos;e</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> f = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;       </span><span class="color-gray">// --+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">    println!(&quot;</span><span class="color-gold">{:?}</span><span class="color-white">&quot;, f);  </span><span class="color-gray">// --+---&apos;f</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(24)" class="copy-fenced-code">Copy</button></pre><h3 id="lifetime-overlapping">Lifetime overlapping</h3><p>In some cases, lifetimes may overlap. The compiler is smart enough to figure out whether the overlapping is safe. Let&apos;s look at the example below.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">foo</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v2 = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;      </span><span class="color-gray">// ------------+--&apos;a</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v3 = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v2[</span><span class="color-gold">1</span><span class="color-white">];  </span><span class="color-gray">// ---+--&apos;b    |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    *v3 = </span><span class="color-gold">3</span><span class="color-white">;              </span><span class="color-gray">// ---+        |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">    v2.</span><span class="color-emerald">push</span><span class="color-white">(</span><span class="color-gold">12</span><span class="color-white">);          </span><span class="color-gray">// ------------+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">bar</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v2 = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;      </span><span class="color-gray">// -----+--&apos;c</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v3 = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v2[</span><span class="color-gold">1</span><span class="color-white">];  </span><span class="color-gray">// ----------+--&apos;d</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">    v2.</span><span class="color-emerald">push</span><span class="color-white">(</span><span class="color-gold">12</span><span class="color-white">);          </span><span class="color-gray">// -----+    |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-white">    *v3 = </span><span class="color-gold">3</span><span class="color-white">;              </span><span class="color-gray">// ----------+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">baz</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v2 = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;    </span><span class="color-gray">// ------------+--&apos;e</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v3 = &amp;</span><span class="color-violet">mut </span><span class="color-white">*v2;  </span><span class="color-gray">// ---+--&apos;f    |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-white">    v3[</span><span class="color-gold">1</span><span class="color-white">] = </span><span class="color-gold">3</span><span class="color-white">;          </span><span class="color-gray">// ---+        |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">    v2.</span><span class="color-emerald">push</span><span class="color-white">(</span><span class="color-gold">12</span><span class="color-white">);        </span><span class="color-gray">// ------------+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">biz</span><span class="color-white">(</span><span class="color-violet">mut </span><span class="color-red">v</span><span class="color-white">: Vec&lt;</span><span class="color-violet">i32</span><span class="color-white">&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v2 = &amp;</span><span class="color-violet">mut</span><span class="color-white"> v;    </span><span class="color-gray">// ------------+--&apos;g</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> v3 = &amp;</span><span class="color-violet">mut </span><span class="color-white">*v2;  </span><span class="color-gray">// ---+--&apos;h    |</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code"><span class="color-white">    v2.</span><span class="color-emerald">push</span><span class="color-white">(</span><span class="color-gold">12</span><span class="color-white">);        </span><span class="color-gray">// ------------+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">23</span><span class="code-fence-code"><span class="color-white">    v3[</span><span class="color-gold">1</span><span class="color-white">] = </span><span class="color-gold">3</span><span class="color-white">;          </span><span class="color-gray">// ---+</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">24</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(25)" class="copy-fenced-code">Copy</button></pre><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">error[E0499]: cannot borrow `*v2` as mutable more than once at a time</span></span>
<span class="code-fence-row"><span class="code-fence-code">  --&gt; src\main.rs:10:5</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">9  |     let v3 = &amp;mut v2[1];</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |                   -- first mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">10 |     v2.push(12);</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |     ^^^^^^^^^^^ second mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">11 |     *v3 = 3;</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |     ------- first borrow later used here</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">error[E0499]: cannot borrow `*v2` as mutable more than once at a time</span></span>
<span class="code-fence-row"><span class="code-fence-code">  --&gt; src\main.rs:22:5</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |</span></span>
<span class="code-fence-row"><span class="code-fence-code">21 |     let v3 = &amp;mut *v2;</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |              -------- first mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">22 |     v2.push(12);</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |     ^^^^^^^^^^^ second mutable borrow occurs here</span></span>
<span class="code-fence-row"><span class="code-fence-code">23 |     v3[1] = 3;</span></span>
<span class="code-fence-row"><span class="code-fence-code">   |     -- first borrow later used here</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">For more information about this error, try `rustc --explain E0499`.</span></span>
<span class="code-fence-row"><span class="code-fence-code">error: could not compile `playground` due to 2 previous errors</span></span>
</code></pre><p><code class="inline-code-span">bar</code> and <code class="inline-code-span">biz</code> are refused due to the overlapping lifetimes, <code class="inline-code-span">foo</code> and <code class="inline-code-span">baz</code> are accepted. It&apos;s because <em>reborrowing</em> a mutable reference is allowed. It&apos;s fine if the lifetime of the re-borrowed reference ends before the referent is used.</p><p>One thing to note is that if we replace <code class="inline-code-span">v2</code> with <code class="inline-code-span">v</code> in line 3, 9, 15 and 21, every function will fail. It never allows multiple mutable reference of the same value.</p><script>/*<![CDATA[*/
const fenced_code_block_contents = ["fn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &x;\n    }\n\n    println!(\"r: {}\", r);\n}\n", "fn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+", "fn big(m: &u32, n: &u32) -> &u32 {\n    if *m < *n { n } else { m }\n}", "", "fn main() {\n    let x = input();       // --------+--'a\n    let z;                 //         |\n    {                      //         |\n        let y = input();   // -+--'b  |\n                           //  |      |\n        z = big(&x, &y);   //  |      |\n    }                      // -+      |\n                           //         |\n    println!(\"z: {}\", z);  //         |\n}                          // --------+", "fn big<'a, 'b>(m: &'a u32, n: &'b u32) -> &'a u32 {\n    if *m < *n { n } else { m }\n}", "", "fn big<'a>(m: &'a u32, n: &'a u32) -> &'a u32 {\n    if *m < *n { n } else { m }\n}", "fn main() {\n    let x = input();       // --------+--'a\n    let z;                 //         |\n    {                      //         |\n        let y = input();   // -+--'b  |\n                           //  |      |\n        z = big(&x, &y);   //  |      |\n    }                      // -+      |\n                           //         |\n    println!(\"z: {}\", z);  //         |\n}                          // --------+", "struct RefInt<'a> {\n    i: &'a u32\n}\n\nfn main() {\n    let x = 3;                // ---------+--'b\n    let s = RefInt { i: &x }; // -+--'c   |\n                              //  |       |\n    println!(\"{}\", s.i);      // -+-------+\n}", "fn func1(n: &u32) -> &u32 {\n    n\n}\n\nfn func2<'a>() -> &'a u32 {\n    let x = 3;\n    &x\n}", "", "fn func3(_: &str) -> (&str, String) {\n    let x = String::from(\"abc\");\n\n    (&x, x)\n}", "", "fn func4(_: &str) -> (String, &str) {\n    let x = String::from(\"abc\");\n\n    (x, &x)\n}", "", "struct RefSelf<'a> {\n    vec: Vec<u32>,\n    refs: Vec<&'a u32>\n}", "impl<'a> RefSelf<'a> {\n\n    pub fn new() -> Self {\n        let vec = vec![0; 10];\n        let refs = vec![&vec[0]];\n\n        RefSelf { vec, refs }\n    }\n\n}", "impl<'a> RefSelf<'a> {\n\n    pub fn new() -> Self {\n        let vec = vec![0; 10];\n        let refs = vec![];\n\n        RefSelf { vec, refs }\n    }\n\n    pub fn add(&'a mut self) {\n        self.refs.push(&self.vec[0]);\n    }\n\n    pub fn clear(&'a mut self) {\n        self.vec.clear();\n    }\n\n}", "fn main() {\n    let mut refself = RefSelf::new();\n    refself.add();\n    println!(\"{}\", refself.refs[0]);\n    refself.clear();\n    println!(\"{}\", refself.refs[0]);\n}", "", "", "fn foo(mut v: Vec<i32>) {\n    let a = &mut v;\n    let b = &mut v;\n}\nfn bar(mut v: Vec<i32>) {\n    let c = &mut v;\n    let d = &mut v;\n    println!(\"{:?}\", c);\n}\nfn baz(mut v: Vec<i32>) {\n    let e = &mut v;\n    let f = &mut v;\n    println!(\"{:?}\", f);\n}", "", "fn foo(mut v: Vec<i32>) {\n    let a = &mut v;  // ---'a\n    let b = &mut v;  // ---'b\n}\nfn bar(mut v: Vec<i32>) {\n    let c = &mut v;       // --------+\n    let d = &mut v;       // ---'d   |    -> Oops!\n    println!(\"{:?}\", c);  // --------+-'c\n}\nfn baz(mut v: Vec<i32>) {\n    let e = &mut v;       // ---'e\n    let f = &mut v;       // --+\n    println!(\"{:?}\", f);  // --+---'f\n}", "fn foo(mut v: Vec<i32>) {\n    let v2 = &mut v;      // ------------+--'a\n    let v3 = &mut v2[1];  // ---+--'b    |\n    *v3 = 3;              // ---+        |\n    v2.push(12);          // ------------+\n}\nfn bar(mut v: Vec<i32>) {\n    let v2 = &mut v;      // -----+--'c\n    let v3 = &mut v2[1];  // ----------+--'d\n    v2.push(12);          // -----+    |\n    *v3 = 3;              // ----------+\n}\nfn baz(mut v: Vec<i32>) {\n    let v2 = &mut v;    // ------------+--'e\n    let v3 = &mut *v2;  // ---+--'f    |\n    v3[1] = 3;          // ---+        |\n    v2.push(12);        // ------------+\n}\nfn biz(mut v: Vec<i32>) {\n    let v2 = &mut v;    // ------------+--'g\n    let v3 = &mut *v2;  // ---+--'h    |\n    v2.push(12);        // ------------+\n    v3[1] = 3;          // ---+\n}"];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
</body>

</html>