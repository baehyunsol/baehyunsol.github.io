<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>이게모야</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/>
    
</head>

<body>




    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<h1 id="이게모야">이게모야</h1><p><div class="toc"><ol type="1"><li><a href="#이게모야">이게모야</a><ol type="1"><li><a href="#mac">Mac</a></li><li><a href="#fc_module">fc_module</a><ol type="1"><li><a href="#internal-registers">Internal Registers</a></li><li><a href="#params">Params</a></li><li><a href="#states">States</a></li></ol></li></ol></li></ol></div></p><h2 id="mac">Mac</h2><ul><li>inputs<ul><li><code class="inline-code-span">din_a</code>, <code class="inline-code-span">din_b</code>, <code class="inline-code-span">din_c</code><ul><li>8 bit, fixed point, 2&apos;s compl</li><li><code class="inline-code-span">din_c</code>는 19bit임.</li></ul></li></ul></li><li>outputs<ul><li><code class="inline-code-span">dout</code><ul><li><code class="inline-code-span">din_a</code> * <code class="inline-code-span">din_b</code> + <code class="inline-code-span">din_c</code></li><li>19 bit, fixed point, 2&apos;s compl</li></ul></li><li><code class="inline-code-span">done</code><ul><li><code class="inline-code-span">dout</code>이 유효해지는 그 cycle 동안만 1로 푱하고 올라옴. 나머지는 0</li></ul></li></ul></li></ul><p>이미 다 구현 돼 있는 듯? 건드릴 필요 X</p><p>얘가 하는 a * b + c는 숫자 하나만 가지고 하잖아? 근데 우리는 행렬 곱을 해야해... 그래서 구현: </p><ul><li>out<sub>0</sub> = i<sub>0</sub> * w<sub>0</sub> + 0</li><li>out<sub>1</sub> = i<sub>1</sub> * w<sub>1</sub> + out<sub>0</sub></li><li>out<sub>2</sub> = i<sub>2</sub> * w<sub>2</sub> + out<sub>1</sub></li><li>...</li><li>out<sub>7</sub> = i<sub>7</sub> * w<sub>7</sub> + out<sub>6</sub></li><li>out<sub>8</sub> = b<sub>0</sub> * 1 + out<sub>7</sub></li></ul><p>out<sub>8</sub>이 첫번째 열의 곱 + bias임. 열이 4개니까 저걸 4번 반복하면 8 * 4 행렬 계산할 수 있음. 완전 naive한 구현이네.</p><p>저런 식으로 중간 결과를 계속 먹이기 때문에 <code class="inline-code-span">din_c</code>가 19bit임.</p><h2 id="fc_module">fc_module</h2><h3 id="internal-registers">Internal Registers</h3><ul><li><code class="inline-code-span">iact</code><ul><li>왜 이름 이따구임.</li><li>input으로 들어온 원소 8개짜리 vector</li></ul></li><li><code class="inline-code-span">weight</code><ul><li>얘랑 <code class="inline-code-span">weight_buff</code>랑 뭐가 다름?</li><li>bram을 읽는 거는 <code class="inline-code-span">weight_buff</code>에 읽고, 계산기한테는 <code class="inline-code-span">weight</code>을 주는 듯?</li><li><code class="inline-code-span">weight_buff</code>가 완성되면 <code class="inline-code-span">weight</code>에다가 <code class="inline-code-span">weight_buff</code>를 copy함.</li><li>mac은 <code class="inline-code-span">data_a</code>, <code class="inline-code-span">data_b</code>, <code class="inline-code-span">data_c</code>를 가져가는데, <code class="inline-code-span">data_b</code>에 <code class="inline-code-span">weight</code>를 주면 됨. 이건 TODO임</li><li>ㅇㅎ <code class="inline-code-span">weight_buff</code>랑 <code class="inline-code-span">weight</code>을 분리해놔야 CUC랑 MUC가 parallel하게 돌아갈 수 있음<ul><li>CUC가 <code class="inline-code-span">weight</code>으로 계산하는 동안 MUC가 <code class="inline-code-span">weight_buff</code>에 다음 값을 쓰고 있으면 그게 더 효율적이잖아</li></ul></li></ul></li><li><code class="inline-code-span">weight_buff</code><ul><li>8 * 4 행렬인 weight는 BRAM 안에 있고 얘는 계산용으로 임시로 쓰는 reg인 듯?</li></ul></li><li><code class="inline-code-span">psum</code><ul><li>mac에서 나온 output 임시로 저장하는 reg인가?</li></ul></li><li><code class="inline-code-span">b_write_done</code><ul><li>DATA_RECV state에서 bram에다가 값을 적잖아? 그거 끝나면 알려주는 flag</li><li>이거 올라가면 DATA_RECV에서 INPUT_SET으로 넘어감</li></ul></li><li><code class="inline-code-span">input_set_done</code><ul><li><code class="inline-code-span">b_write_done</code>이랑 비슷한 듯? INPUT_SET 끝나면 알려주는 flag</li></ul></li><li><code class="inline-code-span">delay</code><ul><li>INPUT_SET, BIAS_SET, WEIGHT_SET 들어오기 전에 항상 <code class="inline-code-span">delay = 0</code>이어야 함.</li><li><code class="inline-code-span">bram_en</code> = 1, <code class="inline-code-span">bram_wen</code> = 0 한 다음에 2 cycle 지나야 bram read가 끝남. 그거 세는 counter<ul><li>그럼 write는 한 cycle이면 됨?</li></ul></li></ul></li><li><code class="inline-code-span">bram_counter</code><ul><li>매 state 들어가기 전에 0으로 초기화</li><li>이거 끝까지 올라가면 각 stage가 끝남</li><li>DATA_RECV<ul><li>input, weight, bias가 연속으로 들어오지? 걔네 언제 끊을 지 세는 counter인 듯</li></ul></li><li>INPUT_SET<ul><li>bram에서 값 읽을 때 index로 씀: <code class="inline-code-span">bram[INPUT_START + bram_counter]</code> 이런 식으로.</li><li>bram이 delay가 2 cycle이니까 <code class="inline-code-span">bram_counter - 2</code> 해서 쓰네.</li></ul></li></ul></li><li><code class="inline-code-span">mac_ireg_set_done</code><ul><li>CUC가 계산하는 동안 MUC가 병렬적으로 동작을 하지? CUC가 준비됐다고 알려줘야 MUC가 <code class="inline-code-span">weight_buff</code>에다가 새로운 값 쓰기 시작할 수 있음</li><li>CUC가 준비되면 이거 올림</li></ul></li><li><code class="inline-code-span">out_counter</code><ul><li>CUC가 연산을 4번 해야하지? (열이 4개니까) 그거 한번 할 때마다 이거 1씩 올림. 이거 4 되면 연산 끝</li></ul></li><li><code class="inline-code-span">element_counter</code><ul><li>아까 <code class="inline-code-span">out_counter</code>는 열을 세는 거였지? 그래서 4개였고. 이건 행을 세는 거임. 그니까 아까 mac에서 봤던 out<sub>0</sub>에서 out<sub>8</sub>까지 세는 거. 그거 세는 counter임.</li><li>그래서 8까지 세면 됨.</li></ul></li></ul><h3 id="params">Params</h3><ul><li><code class="inline-code-span">BYTE_SIZE = 8</code><ul><li>8bit fixed point num을 쓰니까 8임. 한 BYTE를 숫자 하나라고 생각하면 될 듯</li></ul></li><li><code class="inline-code-span">INPUT_SIZE = 8</code><ul><li>input으로 원소 8개짜리 vector가 들어옴</li></ul></li><li><code class="inline-code-span">OUTPUT_SIZE = 4</code><ul><li>output으로 원소 4개짜리 vector가 나감</li></ul></li><li><code class="inline-code-span">WEIGHT_SIZE = 8 * 4</code><ul><li>중간에 곱하는 행렬이 8 * 4임.</li></ul></li><li><code class="inline-code-span">BIAS_SIZE = 4</code><ul><li>중간에 더하는게 원소 4개짜리 vector임</li></ul></li><li><code class="inline-code-span">INPUT_START_ADDRESS</code>, <code class="inline-code-span">WEIGHT_START_ADDRESS</code>, <code class="inline-code-span">BIAS_START_ADDRESS</code><ul><li>bram 안에 0 ~ 1: input, 4 ~ 11: weight, 14: bias 이렇게 들어있다는 뜻인 듯?</li><li>input = 8num * 8bit = 64 bit = 2줄 (bram 한 줄이 32bit) 이렇게 생각하면 다 맞는 듯</li></ul></li></ul><h3 id="states">States</h3><p>MUC가 INPUT_SET이랑 BIAS_SET이랑 WEIGHT_SET 다 끝내고 <code class="inline-code-span">bram_oreg_set_done</code> 올리면 CUC가 동작 시작하는 듯? ㅇㅇ 곱하기 전에 bram에서 값을 읽고 시작하는 거임!</p><p>근데 <code class="inline-code-span">weight_buff</code>가 8 * 4 행렬이 아니고 8 * 1 vector 인 걸로 봐서 MUC &lt;-&gt; CUC를 4번 반복해야 하는 듯</p><hr/><p>?? 이게 말이 됨?</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">INPUT_SIZE[9:2] + 2: 4</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">INPUT_SET</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">first cycle</span></span>
<span class="code-fence-row"><span class="code-fence-code">  delay: 0 -&gt; 1</span></span>
<span class="code-fence-row"><span class="code-fence-code">  bram_counter: 0 -&gt; 1</span></span>
<span class="code-fence-row"><span class="code-fence-code">  addr: ? -&gt; START + 0</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">second cycle</span></span>
<span class="code-fence-row"><span class="code-fence-code">  delay: 1 -&gt; 2</span></span>
<span class="code-fence-row"><span class="code-fence-code">  bram_counter: 1 -&gt; 2</span></span>
<span class="code-fence-row"><span class="code-fence-code">  addr: START + 0 -&gt; START + 1</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">third cycle</span></span>
<span class="code-fence-row"><span class="code-fence-code">  bram_counter: 2 -&gt; 3</span></span>
<span class="code-fence-row"><span class="code-fence-code">  addr: START + 1 -&gt; START + 2</span></span>
<span class="code-fence-row"><span class="code-fence-code">  iact[32 * 0 + : 32] &lt;= dout</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">forth cycle</span></span>
<span class="code-fence-row"><span class="code-fence-code">  bram_counter: 3 -&gt; 4</span></span>
<span class="code-fence-row"><span class="code-fence-code">  addr: START + 2 -&gt; START + 3</span></span>
<span class="code-fence-row"><span class="code-fence-code">  iact[32 * 1 + : 32] &lt;= dout</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code">fifth cycle</span></span>
<span class="code-fence-row"><span class="code-fence-code">  input_set_done: 0 -&gt; 1</span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
</code></pre><p>ㅇㅎ bram이 inertial delay가 아니고 gate delay라고 생각해야할 듯?</p>
        <a id="bottom"></a>
    </article>





    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
</body>

</html>