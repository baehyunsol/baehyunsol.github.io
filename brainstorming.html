<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>brainstorming</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/>
    
</head>

<body>




    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<p><div class="toc"><ol type="1"><li><a href="#modules">Modules</a><ol type="1"><li><a href="#mainv"><code class="inline-code-span">main.v</code></a></li><li><a href="#compute_topv"><code class="inline-code-span">compute_top.v</code></a></li><li><a href="#interface_topv"><code class="inline-code-span">interface_top.v</code></a></li><li><a href="#_module"><code class="inline-code-span">*_module</code></a></li></ol></li><li><a href="#axis">AXIS</a></li><li><a href="#apb">APB</a></li><li><a href="#기타">기타</a></li></ol></div></p><h1 id="modules">Modules</h1><h2 id="mainv"><code class="inline-code-span">main.v</code></h2><ul><li><code class="inline-code-span">compute_top</code>과 <code class="inline-code-span">interface_top</code>만 덩그러니 있음</li><li>input으로는 uart와 clk, reset이 있고</li><li>output으로는 uart와, ddr3(와 관련된 아주 많은 것들)가 있음!</li></ul><h2 id="compute_topv"><code class="inline-code-span">compute_top.v</code></h2><ul><li><code class="inline-code-span">fc_top</code>, <code class="inline-code-span">conv_top</code>, <code class="inline-code-span">pool_top</code> 3개만 있음. 끝!</li><li>각 module이 APB/AXI를 통해서 외부와 소통하지? 그 wire들이 <code class="inline-code-span">compute_top</code>의 input/output으로 전부 꽂혀있음</li></ul><h2 id="interface_topv"><code class="inline-code-span">interface_top.v</code></h2><ul><li>input output이 무지하게 많음<ul><li>uart도 여기에 direct로 들어오고</li><li>ddr3와 관련된 output/inout도 엄청 많고</li><li>vdma도 3종류(conv, fc, pool)가 있고</li><li>apd도 3종류(conv, fc, pool)가 있음</li></ul></li></ul><h2 id="_module"><code class="inline-code-span">*_module</code></h2><p>디렉토리가 3개가 있음: <code class="inline-code-span">conv_module</code>, <code class="inline-code-span">pool_module</code>, <code class="inline-code-span">fc_module</code>. 셋이 내용이 거의 비슷함. 그니까 여기선 걍 conv만 보자</p><ul><li><code class="inline-code-span">conv_top</code><ul><li><code class="inline-code-span">conv_apb</code>, <code class="inline-code-span">conv_module</code>, <code class="inline-code-span">clk_counter</code>만 연결돼 있음! 저 모듈들의 port를 수정한게 아닌 이상 딱히 수정할 부분이 없음</li></ul></li><li><code class="inline-code-span">clk_counter</code><ul><li>Conv 계산하는데 몇 cycle 걸렸는지 세는 module! 수정하지 말래</li></ul></li><li><code class="inline-code-span">conv_module.v</code><ul><li>ports<ul><li>얘가 master일 때와 slave일 때의 AXIS wire들이 쭈루룩 있음<ul><li>data 보낼 땐 master고 받을 땐 slave임</li></ul></li><li>clk, reset을 받음</li><li>conv_start를 받고 conv_done을 보냄</li></ul></li><li><code class="inline-code-span">conv_top</code>한테 <code class="inline-code-span">conv_start</code>를 받으면 열심히 작업을 한 다음에 결과를 AXIS로 보내고, <code class="inline-code-span">conv_top</code>한테 <code class="inline-code-span">conv_done</code>을 보냄</li><li>족보 분석<ul><li><code class="inline-code-span">command</code>라는 2bit짜리 input을 받음. 얘는 <code class="inline-code-span">conv_apb</code>한테 받음. 아마 Python이 준 거겠지?<ul><li>첫번째 command: feature를 AXIS로 받아서 DRAM에 저장</li><li>두번째 command: bias를 AXIS로 받아서 DRAM에 저장</li><li>세번째 command: weight를 AXIS로 받아서 DRAM에 저장하고 conv를 계산</li></ul></li><li>feature DRAM과 bias DRAM, weight DRAM이 각각 따로 있음. 전부 ip를 사용하는 듯?</li><li>AXIS로 입력을 받는 거랑 DRAM에 저장하는 거랑 전부 과정이 아주 길기 때문에 FSM을 이용해서 control함. 그래서 코드가 긺</li><li>계산은 여기서 안함. <code class="inline-code-span">mac3x3</code> module을 따로 만들어두고 걔한테 모든 계산을 시킴<ul><li>계산도 여러 cycle 동안 하기 때문에 그거 관리하는 커다란 FSM이 있음</li></ul></li></ul></li></ul></li><li><code class="inline-code-span">conv_apb.v</code><ul><li>Python이 보낸 신호가 얘를 거쳐서 <code class="inline-code-span">conv_module</code>한테 감. 즉, Python이 계산 시작하라고 시키면 얘가 <code class="inline-code-span">conv_module</code>한테 <code class="inline-code-span">conv_start</code> 보내고, <code class="inline-code-span">conv_module</code>이 <code class="inline-code-span">conv_done</code> 보내면 얘가 Python한테 apb로 알려주는 듯?</li><li><code class="inline-code-span">PWRITE</code>가 들어오면 <code class="inline-code-span">PWDATA</code>를 읽어서 내부 reg에 값을 씀</li><li><code class="inline-code-span">PWRITE</code>가 안 들어오면 <code class="inline-code-span">prdata_reg</code>에 값을 씀<ul><li>무슨 값을 쓸지는 <code class="inline-code-span">PADDR</code>을 보고 결정</li><li><code class="inline-code-span">prdata_reg</code>는 <code class="inline-code-span">PRDATA</code>라는 output에 연결돼 있고 쟤는 <code class="inline-code-span">interface_top</code>을 통해서 Python과 연결돼 있음</li></ul></li></ul></li></ul><h1 id="axis">AXIS</h1><ul><li>READY<ul><li>slave가 data 받을 준비 되면 READY를 1로 띄움</li></ul></li><li>VALID<ul><li>master가 data 보낼 준비 되면 VALID를 1로 띄움</li><li>띄우자마자 DATA도 같이 보냄</li><li>DATA가 가는 동안 계속 1</li></ul></li><li>DATA<ul><li>master가 보내는 actual data</li><li>매 clock마다 DATA_WIDTH만큼의 data를 보냄. default 값은 32bit로 돼 있네</li></ul></li><li>LAST<ul><li>master가 DATA를 보내다가 마지막 DATA가 갈 때 LAST를 1로 띄움</li><li>PPT 보면 LAST가 1 되고 그 다음 clock에 VALID가 0됨</li></ul></li><li>KEEP<ul><li>이게 1이어야지만 같이 가는 DATA가 qualified인가봐... 잘 모르겠음 ㅎㅎ</li><li>PPT에서는 <code class="inline-code-span">4&apos;b1111</code>로 고정이라는데?</li></ul></li><li>USER<ul><li>추가로 보내고 싶은 정보가 있으면 이거로 보내래</li><li>PPT에서는 <code class="inline-code-span">1&apos;b0</code>으로 고정이라는데?</li></ul></li></ul><h1 id="apb">APB</h1><p>Protocol 자체는 단순한 듯? addr, rdata, wdata 등등 있고, addr의 값을 읽거나 addr에 wdata를 쓰거나... 아주 간단함!</p><p>원래대로면 <code class="inline-code-span">conv_apb</code>를 구현할 때 거대한 array를 만들고 i번 addr을 읽으려고 하면 <code class="inline-code-span">array[i]</code>를 보내는게 정석이지? 근데 족보는 그렇게 안함. command, conv_done, conv_start 등등의 reg를 전부 따로 만들어 두고, command의 addr이 들어오면 prdata에 command를 쓰고 conv_done의 addr이 들어오면 prdata에 conv_done을 쓰는 방식으로 구현돼 있음. skeleton 준 거 보면 그런 식으로 짜는게 더 편할 듯?</p><p>어느 주소에 어느 값을 mapping할지는 우리 마음임. 그래서 Python code 수정해야함. (ex: Python이 FPGA한테 3이라는 command를 쓰고 싶다? 근데 command가 6번 주소에 있다? 저 주소가 6인 건 내가 정한 거여서 Python에도 반영해줘야함)</p><p>Python이 control register로 FPGA에 명령 내리라는게 이 얘긴가??</p><h1 id="기타">기타</h1><p><code class="inline-code-span">`ifndef</code>같은 것도 나옴 ㅋㅋ</p>
        <a id="bottom"></a>
    </article>





    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
</body>

</html>