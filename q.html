<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>q</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/>
    
</head>

<body>




    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><div id="settingsmenu"><table><thead><tr><th colspan="2"><div class="align-right"> <span class="size-giant"><a id="settingsclosebutton">&#10006;</a></span></div></th></tr></thead><tbody><tr><td><div class="align-right">Theme:</div></td><td><div class="align-left"><a id="changethemebutton">Set Light Theme</a></div></td></tr><tr><td><div class="align-right">Horizontal Padding:</div></td><td><div class="align-left"><a id="growhorizontalbutton">Grow</a> <a id="shrinkhorizontalbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Font Size:</div></td><td><div class="align-left"><a id="growfontbutton">Grow</a> <a id="shrinkfontbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Settings:</div></td><td><div class="align-left"><a id="savesettingsbutton">Save All</a> <a id="discardsettingsbutton">Discard All</a></div></td></tr></tbody></table></div></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<h1 id="summary">Summary</h1><p>in-process isolation: cheaper than inter-process communication</p><p>Modified the Compiler</p><ol type="1"><li>Heap objects allocated by unsafe Rust<ul><li>goes to <em>unsafe region</em></li><li>the region has a predefined address range</li><li>uses a modified allocator</li></ul></li><li>Stack objects allocated by unsafe Rust<ul><li>goes to <em>special stack</em></li><li>the stack is positioned in the <em>unsafe region</em></li></ul></li><li>&quot;all memory operations in an unsafe block are instrumented with masking to deny out-of-region access&quot;<ul><li>what does it mean?</li></ul></li><li>External Libraries<ul><li>they&apos;re all unsafe</li><li>Uses <a href="intelmpk">Intel MPK</a> to isolate unsafe pages</li></ul></li></ol><div class="box"><p><span class="size-giant">Intel MPK</span></p><p><a id="intelmpk"></a></p><p>Each page has a 4-bit key (page group id)</p><p>Each process has a permission per each group</p><p>The paper says it has some pitfalls,... no idea</p></div><div class="box"><p>Exploits</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">static mut</span><span class="color-white"> offset: </span><span class="color-violet">usize </span><span class="color-white">= </span><span class="color-gold">1</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">main</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-gray">// ...</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> x = </span><span class="color-gold">3</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">    <span class="color-violet">unsafe </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-code">        <span class="color-gray">// write `100` at `&amp;x + offset`</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code></pre><p>If the attacker can manipulate <code class="inline-code-span">offset</code> (it&apos;s global!), they can write <code class="inline-code-span">100</code> at whatever they want.</p><p>Zip 예시는 제대로 이해 못함 ㅋㅋ <code class="inline-code-span">a[b - c]</code> 했는데 <code class="inline-code-span">usize</code>가 overflow가 나면 저게 buffer overflow 난다는 얘기인 듯?</p><p>Formatter: <code class="inline-code-span">printf(&quot;%d%d%d&quot;, 1)</code> -&gt; read 8 more bytes -&gt; prevented in Rust, not in C</p></div><p>Existing frameworks</p><ul><li>developers have to tell the tool which objects are used in unsafe contexts</li><li>some runs external libraries in another process, for sandboxing<ul><li>high overhead</li></ul></li></ul><hr/><p>It allows some crates/libs: If TRust prohibits ALL the <code class="inline-code-span">unsafe</code> blocks, there&apos;s no safe object at all! -&gt; It mentions the Coq-proof</p><hr/><p>Impl</p><ol type="1"><li>Points-to Analysis<ul><li>모든 allocation을 분석: unsafe block을 한번이라도 지나가는 Pointer는 전부 unsafe region에 할당</li><li>100 ~ 120을 할당했는데 116 ~ 118이 unsafe block에서 나타나면 100 ~ 120 전체를 unsafe region에 할당</li></ul></li><li>Function cloning<ul><li>이해 X</li></ul></li><li>Instrumenting Memory Access<ul><li>unsafe block에서 호출하는 store instruction 앞에는 무조건 bound checking 코드를 추가함<ul><li>해당 store의 위치가 전부 unsafe region인지 확인</li></ul></li></ul></li><li>Unsafe Object Stack<ul><li>기존의 safe stack에 추가로 stack 2개를 더 사용</li><li>return address는 safe stack에 있고, unsafe object는 unsafe stack에 들어가는 듯<ul><li>unsafe stack은 return address 필요 없음?</li></ul></li><li>r15 레지스터에 unsafe stack pointer 저장<ul><li>컴파일러가 저 레지스터 안 쓰도록 고쳐놨음</li></ul></li></ul></li><li>External Libraries<ul><li>원래는 callee(external lib)가 return address 관리함<ul><li>그럼 callee가 악의를 품고 fake stack 만든 다음에 return address를 거기로 보낼 수도 있음</li></ul></li><li>external로 넘어가기 전에 원래 stack의 내용을 안전한 곳에 저장<ul><li>Intel MPK 덕분에 external lib은 쟤를 수정할 수 없음</li></ul></li><li>external 끝나고 Rust로 돌아올 때 stack의 내용이 바뀌어 있으면 공격당한 걸로 간주</li></ul></li></ol><h1 id="questions">Questions</h1><ol type="1"><li>Why those frameworks?<ul><li>Safe Rust: Safety &gt; Performance</li><li>Unsafe Rust: Performance &gt; Safety</li><li>Those frameworks: Safety &gt; Performance<ul><li>But Safe Rust is safer</li><li>Rudra?</li><li>Or, is it just an analyser that runs only once?<ul><li>like Stacked Borrows</li></ul></li></ul></li></ul></li><li><del>If an object is allocated in safe region and used in unsafe blocks, how does TRust know that?</del><ul><li>처음에 analysis하면서 &quot;identifies pointers used in unsafe memory operations&quot;한다는데?</li><li>&quot;An allocation site remains safe only if TRUST can soundly conclude that the pointer obtained from the allocation site never flows to external libraries and used for writing in unsafe blocks&quot;</li><li>&quot;An allocation site is classified as unsafe if it produces a pointer that flows to at least one instruction in an unsafe block.&quot;</li><li>If <code class="inline-code-span">vec.len</code> is modified in an unsafe block, TRust considers the entire <code class="inline-code-span">vec</code> as unsafe.</li></ul></li><li>Is the goal of this project is to prevent buffer overflows, rather than preventing memory leaks?</li><li>What if a sensitive data is in the unsafe region? Can it guarantee any safety?</li><li>Multiple stacks: Does it need multiple return addresses?<ul><li>Can the attacker hijack the return address of an unsafe stack?</li></ul></li></ol>
        <a id="bottom"></a>
    </article>





    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
</body>

</html>
