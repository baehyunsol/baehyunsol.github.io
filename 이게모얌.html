<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>이게모얌</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> 
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/>
    
</head>

<body>




    <nav>
<p><a id="settingsopenbutton">&#9728;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p><div id="settingsmenu"> <a id="settingsclosebutton">&#10006;</a> <a id="changethemebutton">Set Light Theme</a> <a id="loosepaddingbutton">&#8592; &#8594;</a> <a id="tightpaddingbutton">&#8594; &#8592;</a> </div></p></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<p>파일을 블록 단위로 쪼개서 전송. 파일 다루는 건 우리가 신경 쓸 필요 X. 네트워크 관련된 것만</p><p><code class="inline-code-span">_ans</code>로 postfix 붙어있는 친구들은 TA의 reference implementation</p><hr/><p>protocol</p><p>http처럼 문자열로 request를 주고 받음</p><ul><li><code class="inline-code-span">REQUEST_TORRENT %d %x %x</code>를 보내면 <code class="inline-code-span">PUSH_TORRENT %d %x %x</code>로 답장하는 식. <code class="inline-code-span">PUSH_TORRENT</code>의 뒤에는 <code class="inline-code-span">torrent_info</code>를 raw byte로 그대로 보냄</li></ul><ul><li>torrent 전송 개시<ul><li>requester -&gt; seeder: REQUEST_TORRENT</li><li>seeder -&gt; requester: PUSH_TORRENT, <code class="inline-code-span">torrent_info</code><ul><li>requester가 이거 받아서 <code class="inline-code-span">torrent_info</code>를 만들고 <code class="inline-code-span">torrent_file* global_torrent_list [512]</code>에 추가</li><li>requester의 peer list에 seeder 추가</li></ul></li><li>requester -&gt; seeder: REQUEST_BLOCK_INFO</li><li>seeder -&gt; requester: PUSH_BLOCK_INFO, <code class="inline-code-span">block_info [MAX_BLOCK_NUM]</code><ul><li>각 file을 여러 block으로 나눠놨지? 각 seed는 일부 block만 갖고 있겠지? 무슨무슨 block을 갖고 있는지를 나타내는 bit field임.</li></ul></li><li>requester -&gt; seeder: REQUEST_BLOCK<ul><li>자기한테 없는데 seeder한테 있는 block 달라고 요청</li></ul></li><li>seeder -&gt; requester: PUSH_BLOCK, block<ul><li>block은 type이 뭐냐 걍 <code class="inline-code-span">char*</code>로 주면 됨?</li></ul></li></ul></li><li>random interval<ul><li>requester -&gt; random: REQUEST_PEERS</li><li>random -&gt; requester: PUSH_PEERS<ul><li>이제 requester는 새로운 peer를 더 알게 됨</li></ul></li><li>requester가 block_info랑 block 달라고 할 수도 있음!!</li></ul></li></ul><p>requester의 함수들은 <code class="inline-code-span">client_routines()</code>에 구현, seeder는 <code class="inline-code-span">server_routines()</code>에 구현</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">REQUEST_TORRENT    [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH]</span></span>
<span class="code-fence-row"><span class="code-fence-code">PUSH_TORRENT       [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH] / [TORRENT_INFO]</span></span>
<span class="code-fence-row"><span class="code-fence-code">REQUEST_PEERS      [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH]</span></span>
<span class="code-fence-row"><span class="code-fence-code">PUSH_PEERS         [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH] [TORRENT_NUM_PEERS] / [PEER_IPS][PEER_PORTS]</span></span>
<span class="code-fence-row"><span class="code-fence-code">REQUEST_BLOCK_INFO [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH]</span></span>
<span class="code-fence-row"><span class="code-fence-code">PUSH_BLOCK_INFO    [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH] / [MY_BLOCK_INFO]</span></span>
<span class="code-fence-row"><span class="code-fence-code">REQUEST_BLOCK      [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH] [BLOCK_INDEX]</span></span>
<span class="code-fence-row"><span class="code-fence-code">PUSH_BLOCK         [MY_LISTEN_PORT] [MY_ID_HASH] [TORRENT_HASH] [BLOCK_INDEX] / [BLOCK_DATA]</span></span>
</code></pre><hr/><p>id_hash: 각 peer마다 고유로 갖고 있는 값인 듯?</p><p>torrent_file.peer_req_num: 각 torrent마다 갖고 있음</p><ul><li>한 peer 한테 request 보냈는데 5연속 fail하면 그 peer는 쓸모 없다고 판단하고 걔를 날려버리면 됨!</li><li>각 peer마다 몇번 연속 실패했는지 세는 array</li><li>block request랑 peer request랑 동시에 이걸로 셈. block 3연속 실패하고 peer 2연속 실패해도 안되나 보네</li></ul><hr/><p><code class="inline-code-span">request_torrent_from_peer</code> 분석</p><ul><li><code class="inline-code-span">fd = connect_socket(peer, port)</code><ul><li><code class="inline-code-span">fd</code> 값 확인해서 error handling하는 거 잊지 말고!</li></ul></li><li><code class="inline-code-span">sprintf</code>로 request 만들어서 <code class="inline-code-span">send_socket</code>으로 보냄</li></ul><p>request랑 push 함수들 구현하는 건 쉬울 듯?? server_routine이랑 client_routine이 핵심인 듯!</p><hr/><p><code class="inline-code-span">server_routine</code></p><ul><li><code class="inline-code-span">recv_socket(fd, buf, len)</code>을 한번 하면 command가 옴. buf를 잘 분석해서 command, port, id_hash 뽑아내셈.<ul><li>이거 <code class="inline-code-span">strtok</code> 써야 할 듯?</li><li><code class="inline-code-span">strtok(buf, &quot; &quot;)</code>하면 cmd 나오고, <code class="inline-code-span">strtok(NULL, &quot; &quot;)</code> 하면 <code class="inline-code-span">MY_ID_HASH</code> 나오고 (int로 변환해야함), <code class="inline-code-span">strtok(NULL, &quot; &quot;)</code>하면 peer_id_hash 나올 듯?</li></ul></li><li>torrent_hash 필요하면 <code class="inline-code-span">unsigned int torrent_hash = strtoul(strtok(NULL, &quot; &quot;), NULL, 16);</code>로 뽑으면 됨.</li><li>추가 data가 더 붙은 친구들은 <code class="inline-code-span">recv_socket</code>을 한번 더해서 해당 정보를 읽어오면 됨! PUSH_TORRENT 구현 참고 ㄱㄱ</li><li>각 cmd 처리 끝나면 <code class="inline-code-span">close_socket</code> 까먹지 말고</li></ul><hr/><p><code class="inline-code-span">client_routine</code></p><ul><li>첫번째 큰 loop<ul><li><code class="inline-code-span">global_torrent_list</code>의 모든 torrent 다 돌면서 각 torrent의 모든 peer 다 돌면서 각 torrent의 모든 block 다 돌면서 없는 block 요청하는 3중 loop<ul><li>3중 loop가 최선임?</li></ul></li><li><code class="inline-code-span">is_peer_requested_add_if_not</code>가 있지? 지금 보는 peer한테 이미 request 보냈는지 아닌지 확인하는 함수<ul><li>이걸로 확인해보고 아직 request 안 보냈으면 보내면 됨. 그게 TODO</li></ul></li></ul></li></ul><ul><li>두번째 큰 loop<ul><li><code class="inline-code-span">update_time_msec</code>: 마지막 update하고 나서 <code class="inline-code-span">peer_update_interval_msec</code> 이상 지났으면 다음 torrent를 update함.<ul><li>한번에 한 torrent만 건드리네. 그래서 <code class="inline-code-span">update_torrent_idx</code> 쓰잖아.</li></ul></li></ul></li></ul><hr/><h1 id="qna">QnA</h1><p>안녕하세요 조교님, 과제 진행 중 의문점이 생겨 질문 드립니다. torrent 과제에 각각 ans function들을 넣고 작동을 시켰을 때, torrent시작 초기에 request torrent 함수를 각 peer가 호출하여 정보를 가져옵니다. 그런게 client구현 안내를 보면, 이미 존재하는 global torrent list를 참조하여 block을 가져오는 기능과 peer update 기능을 구현하라 할 뿐, request client를 호출하라는 안내는 없습니다. client구현시 request torrent역시 호출해야 하는 건가요? 그렇지 않다면, ans 함수들을 이용하여 프로그램 동작시 request client는 어디서 호출되는 건가요?</p><p>네 부르실 필요가 없습니다. 메인 루프의 request_from_hash 함수가 호출되는것을 볼 수 있는데 이 함수를 통해서 request torrent 요청이 전달 됩니다.</p><hr/><p>server_routine의 PUSH_BLOCK일 때를 구현 중 의문이 생겨 질문드립니다. 제가 이해한 바로는 PUSH_BLOCK command를 받았을 때 torrent의 block info만 업데이트하면 될 것 같은데, 각주의 힌트에 따르면 update_peer_block_info를 사용하는 것이 좋을 것이라고 되어 있습니다. peer_block_info를 업데이트 하는 이유가 무엇인가요?</p><p>검토해본 결과 주석에 오류가 있는것 같습니다. update_peer_block_info를 쓸 필요는 없습니다. 감사합니다.</p><hr/><p>과제2를 한 번 돌리고 나서 다시 돌리면 이미 프로그램이 torrent_block_info가 초기화가 되지 않는지 dlownloaded가 100%로 나옵니다. 이를 초기화할 방법이 있나요? (_ans 함수로로 돌렸을 때 있는 문제입니다.)</p><p>처음에는 가지고 있는 애들만 100퍼센트로 나오다가 시간이 지나면 다른 두 파일들이 추가되서 다운로드가 될텐데 혹시 진행이 잘 안되시나요?</p><hr/><p>Problem 2에서 torrent file 내의 peer list에 자기 자신이 포함되어도 되는지 문의드립니다.</p><p>네 주석에 적힌데로 서버 루틴에서 이를 적절히 핸들링한다면 문제가 없습니다</p><hr/><p>torrent struct : The peer same index are used across all peer_[XXX] arrays for each unique peer. 여기서 peer index는 0부터 시작하나요?</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">char</span><span class="color-white"> peer_ip</span><span class="color-white">[</span><span class="color-white">MAX_PEER_NUM</span><span class="color-white">]</span><span class="color-white">[</span><span class="color-white">STRING_LEN</span><span class="color-white">]</span><span class="color-white">;</span>             <span class="color-gray">//</span><span class="color-gray"> IP address of each peer
</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">int</span><span class="color-white"> peer_port</span><span class="color-white">[</span><span class="color-white">MAX_PEER_NUM</span><span class="color-white">]</span><span class="color-white">;</span><span class="color-white">                        </span><span class="color-gray">//</span><span class="color-gray"> Port number of each peer
</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">char</span><span class="color-white"> peer_req_num</span><span class="color-white">[</span><span class="color-white">MAX_PEER_NUM</span><span class="color-white">]</span><span class="color-white">;</span><span class="color-white">                    </span><span class="color-gray">//</span><span class="color-gray"> Number of pending requests to peers
</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-violet">char</span><span class="color-white"> peer_block_info</span><span class="color-white">[</span><span class="color-white">MAX_PEER_NUM</span><span class="color-white">]</span><span class="color-white">[</span><span class="color-white">MAX_BLOCK_NUM</span><span class="color-white">]</span><span class="color-white">;</span><span class="color-white">  </span><span class="color-gray">//</span><span class="color-gray"> Block info of each peer</span></span></span>
</code></pre><p>등에서 peer에 관한 정보가 앞에서 부터 채워지는 건지 궁금합니다. 그리고 peer를 제거하면 peer index는 앞에서부터 비어있는 index가 없도록 다시 정렬되나요?</p><p>네 맞습니다. add peer index 를 이용하면 순차적으로 증가합니다.</p><hr/><p>그리고 디버깅을 해보니 계속 while ((newsockfd = accept_socket(sockfd, &amp;client_addr, &amp;slen, max_listen_time_msec)) &gt;= 0) 여기서 accept가 실패하는데 혹시 가능한 원인이 있을지도 여쭤보고 싶습니다..</p><p>따로 메시지가 안뜨면 타임 아웃일 확률이 높습니다. 두개의 터미널에서 실행하고 조금 기다리시면 통신이 되실수도 있습니다.</p><hr/><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code">  <span class="color-gray">//</span><span class="color-gray"> Make sure that no more than 1 block data requests are sent to a same peer at once.</span></span></span>
</code></pre><p>1 block data request라는 것이 client routine 당 1 block data requesst라는 것을 의미하는 걸까요? 아니면 client routine 내의 global torrent list 를 탐색하는 loop 한 번당 1 block data request를 말하는 것인가요?</p><p>한 클라이언트 루틴당 한번이 맞습니다!</p><hr/><p>peer list에 10명이 추가된 뒤 peer index 2, 4, 6, 7에 해당하는 peer가 remove되는 상황을 가정할 때 나머지 0,1,3,5,8,9번 peer의 ip와 port배열에 저장된 값들이 가 index 0-5로 재정렬 되는 것이 맞나요?</p><p>제거할때 remove_peer에서 이를 정렬해주게 됩니다.</p><hr/><p>client routine에서 peer_req_num이 PEER_EVICTION_NUM보다 작으면 해당되는 peer를 evict한다고 명시되어있습니다. 이때 peer_req_num은 가지고 있는 모든 torrent에서의 그 peer의 누적된 값인지, 아니면 각 torrent에서의 값인지 궁금합니다.</p><p>각 토렌트에 저장되는값입니다. 한 피어의 모든 토렌트는 peer_req_num이 존재하기에, 한 피어의 입장에서 같은 파일에 대해 5번 실패하면 eviction됩니다. 예를 들어서 1,2,3,4,5 토렌트가 있고 a,b 피어가 있다면, b가 1,2,3,4,5 파일에 대해 한번씩 실패한다고 해서 evict 되지않습니다.</p><hr/><p>Use peer_reqs array to keep track of which peers have been requested for a block. 위 힌트의 의도가, peer한테 block을 요청할 경우 peer_reqs[i]를 1로 올렸다가,  request가 성공하든 실패하든 끝나면 다시 0으로 내리라는 뜻이 맞나요? Use request_block_from_peer() to request a block from a peer. Increment peer_req_num for the peer. 위 힌트의 경우에는, request_block_from_peer를 할 때 peer_req_num[i]를 1로 올렸다가, request가 성공하든 실패하든 끝나면 다시 0으로 내리라는 뜻이 맞나요? 아니면 올리기만 하고 내리는 일은 없어야 하는 것인가요?</p><p>peer_reqs 는 한 클라이언트루프내에서 같은 피어에게 여러번 요청을 하지 않기 위함입니다. 반복문으로 모든 토렌트에 대해 훑는동안 보내기로 한 피어가 이미 보냈다면, 다시 보내지 않기 위함입니다. 따라서 다시 내릴 이유는 없습니다. (매 루프마다 0으로 초기화시켜서 선언하므로)</p><hr/><p>peer_req_num은 루프 내에서 초기화되지 않으므로 직접 내려줘야 하는 게 맞나요?</p><p>peer_req_num의 경우 요청이 성공했을경우, 즉 노드가 살아있다 판단되면 0으로 하나씩 바꿔주면 됩니다.</p><hr/><p>스켈레톤 코드에 따르면 가장 안쪽 for loop에서 먼저 is_peer_requested_add_if_not를 호출하여 peer가 이번 client call에서 request를 받은 적이 없는 경우 linked list에 추가하는 것으로 이해했습니다. 그런데 peer_idx에 해당하는 peer가, block_idx에 해당하는 block을 보유하고 있는지 먼저 확인을 해야 하는 게 아닌 것인지 궁금합니다. 확인하지 않는다면 peer에게는 해당 block이 없어 request를 받지 않음에도 linked list에 추가되는 경우가 발생할 수 있을 것이라 생각했습니다.</p><p>네 맞습니다. 현재 거의다 수정하였고, 5분내로 다시 수정된 코드를 업로드 하겠습니다.</p><hr/><ol type="1"><li>eviction에 대한 test case를 만들려고 해당 파일이 없는 peer한테 그 파일을 request from hash로 불러올려고 하였습니다. 하지만 딱히 터미널에 보여지는건 없고 그냥 무시된거 같은데, 이러한 경우에서 request from hash의 behavior 가 궁금합니다.</li><li>새로 올라온 skeleton code를 확인하였습니다. 저번 skeleton코드로 올바른 구현을 하였고 , 저번 skeleton 코드에 기반된 코드를 제출하면 불이익이 있는지 궁금합니다.</li></ol><ol type="1"><li>토렌트가 없으면 무시 되는것이 맞습니다. (즉 아무일도 일어나지 않습니다) 대답은 실제 서버루틴에서 하기에 서버루틴을 더 확인해보시면 좋을것 같습니다.</li><li>네 그럴경우 감점은 없습니다!</li></ol><hr/><p>network_functions.h 를 보면, 다음과 같은 설명이 있습니다. (client routine에 대한 설명 중)</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-gray">//</span><span class="color-gray"> If a request to a peer fails, increment the pending request count for that peer, from the current torrent&apos;s peer_req_num.</span></span></span>
</code></pre><p>저는 이 주석을 보고, 실패한 요청에 대해서 peer_num_req 를 update 하는 것이라고 생각하고, 그렇게 구현하였습니다. 그런데, main.c 의 주석을 보면 (client routine 에 대한 설명 중)</p><pre class="fenced-code-block"><code><span class="code-fence-row"><span class="code-fence-code"><span class="color-gray">//</span><span class="color-gray"> Use request_block_from_peer() to request a block from a peer. Increment peer_req_num for the peer.
</span></span></span>
<span class="code-fence-row"><span class="code-fence-code"><span class="color-gray">//</span><span class="color-gray"> If request_block_from_peer() returns -1, the request failed.</span></span></span>
</code></pre><p>이 주석을 보면, Request 를 할때 일단 무조건적으로 peer_req_num 을 올려주라는 것으로 보입니다. 아래 질문글을 보고 network_header.h 에 대한 설명이 맞다고 보고 그렇게 구현하였고, 작동 자체는 문제없이 하는것을 확인하였습니다. 그러나 확실히 확인하는 것이 좋을 것 같아 질문 남깁니다.</p><p>주석에 오류가 있는것 같습니다. 학생의 구현이 맞습니다.</p><hr/><p>I wonder if more than three torrent file share programs work during the verification.  If so, would there be no deduction if all the files are shared properly even if there are some error messages?</p><p>ERROR - Peer port is out of range - (n)</p><p>This was my error, which I already fixed it. But still I&apos;m wondering if this itself can cause a deduction, even if all the files are shared properly. And I saw in main.c that it works in a situation where more than two peer is connected, so I don&apos;t think you need to answer the first question. Thank you.</p><p>아직 응답 X</p>
        <a id="bottom"></a>
    </article>





    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
</body>

</html>