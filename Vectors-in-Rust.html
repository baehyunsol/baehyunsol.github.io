<!DOCTYPE html><html>

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    
    <title>Vectors-in-Rust</title>
    
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"/>
    <!--<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;display=swap" rel="stylesheet"/> -->
    
    <link href="page.css" rel="stylesheet"/><link href="markdown.css" rel="stylesheet"/><link href="nav.css" rel="stylesheet"/><link href="header.css" rel="stylesheet"/>
    
</head>

<body>


    <header>
<p><div class="topmenu deactivated"><a href="index.html">Home</a> <a href="Articles.html">Articles</a> <a href="Tags.html">Tags</a></div><div class="mobileview"><a id="navbutton">&#9776;</a></div></p>
    </header>



    <nav>
<p><a id="settingsopenbutton">&#9776;</a><a href="#top">&#9650;</a><a href="#bottom">&#9660;</a></p><div id="settingsmenubg"><p></p><div id="settingsmenu"><table><thead><tr><th colspan="2"><div class="align-right"> <span class="size-giant"><a id="settingsclosebutton">&#10006;</a></span></div></th></tr></thead><tbody><tr><td><div class="align-right">Theme:</div></td><td><div class="align-left"><a id="changethemebutton">Set Light Theme</a></div></td></tr><tr><td><div class="align-right">Horizontal Padding:</div></td><td><div class="align-left"><a id="growhorizontalbutton">Grow</a> <a id="shrinkhorizontalbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Font Size:</div></td><td><div class="align-left"><a id="growfontbutton">Grow</a> <a id="shrinkfontbutton">Shrink</a></div></td></tr><tr><td><div class="align-right">Settings:</div></td><td><div class="align-left"><a id="savesettingsbutton">Save All</a> <a id="discardsettingsbutton">Discard All</a></div></td></tr></tbody></table></div></div>
    </nav>


    <article class="markdown">
        <a id="top"></a>
<div class="align-right"><p>Last Updated: 7.May.2023</p><p>Tags: <a href="tag-rust.html">#rust</a>, <a href="tag-smart-pointers.html">#smart-pointers</a></p></div><h1 id="vectors-in-rust">Vectors in Rust</h1><p>It&apos;s the second article of the Rust smart pointers series. This time, it&apos;s vectors. If you&apos;re writting code in Rust, there&apos;s no way you can avoid using this type. Knowing the internals of one of the most frequently used type will improve our code a lot!</p><div class="box"><p>All the std code in this article is from the lastest Rust repo as I&apos;m writting this article (07-May-2023). The implementation may change over time.</p></div><h2 id="definition">Definition</h2><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">stable</span><span class="color-white">(feature = &quot;</span><span class="color-green">rust1</span><span class="color-white">&quot;, since = &quot;</span><span class="color-green">1.0.0</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">cfg_attr</span><span class="color-white">(</span><span class="color-aqua">not</span><span class="color-white">(test), rustc_diagnostic_item = &quot;</span><span class="color-green">Vec</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">rustc_insignificant_dtor</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-violet">pub struct </span><span class="color-white">Vec&lt;T, </span><span class="color-dark">#</span><span class="color-white">[unstable(feature = &quot;allocator_api&quot;, issue = &quot;32838&quot;)] A: Allocator = Global&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">    buf: RawVec&lt;T, A&gt;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">    len: </span><span class="color-violet">usize</span><span class="color-white">,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(0)" class="copy-fenced-code">Copy</button></pre><p>Above is the definition of <code class="inline-code-span">Vec&lt;T&gt;</code>. Ignoring the macros for debug information, it consists of a buffer and a length. The buffer has type <code class="inline-code-span">RawVec&lt;T&gt;</code>, which looks like below.</p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">allow</span><span class="color-white">(missing_debug_implementations)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-violet">pub</span><span class="color-white">(</span><span class="color-violet">crate</span><span class="color-white">) </span><span class="color-violet">struct </span><span class="color-white">RawVec&lt;T, A: Allocator = Global&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-red">ptr</span><span class="color-white">: Unique&lt;T&gt;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">    <span class="color-red">cap</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">    <span class="color-red">alloc</span><span class="color-white">: A,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(1)" class="copy-fenced-code">Copy</button></pre><p><code class="inline-code-span">RawVec</code> has 3 fields: pointer to the actual data, capacity of the buffer, and a memory allocator. <a href="#uniqueptr"><code class="inline-code-span">Unique</code></a> is a speical type of raw pointer.</p><p>A vector is very simple. It has a pointer to a buffer, a length and a capacity. Just like what we saw in Data Structure courses.</p><h2 id="initialization-of-a-vector">Initialization of a vector</h2><p>What happens when we initialize a vector? The most common way to initialize a vector is using <code class="inline-code-span">vec!</code>. <code class="inline-code-span">vec!</code> is defined like below.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">cfg</span><span class="color-white">(</span><span class="color-aqua">all</span><span class="color-white">(</span><span class="color-aqua">not</span><span class="color-white">(no_global_oom_handling), </span><span class="color-aqua">not</span><span class="color-white">(test)))]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">macro_export</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">stable</span><span class="color-white">(feature = &quot;</span><span class="color-green">rust1</span><span class="color-white">&quot;, since = &quot;</span><span class="color-green">1.0.0</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">rustc_diagnostic_item </span><span class="color-white">= &quot;</span><span class="color-green">vec_macro</span><span class="color-white">&quot;]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">allow_internal_unstable</span><span class="color-white">(rustc_attrs, liballoc_internals)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-emerald">macro_rules! </span><span class="color-white">vec {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    () =&gt; (</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">        <span class="color-red">$crate</span><span class="color-white">::__rust_force_expr!(</span><span class="color-red">$crate</span><span class="color-white">::vec::Vec::new())</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    );</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-white">    (</span><span class="color-red">$elem</span><span class="color-white">:</span><span class="color-violet">expr</span><span class="color-white">; </span><span class="color-red">$n</span><span class="color-white">:</span><span class="color-violet">expr</span><span class="color-white">) =&gt; (</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">        <span class="color-red">$crate</span><span class="color-white">::__rust_force_expr!(</span><span class="color-red">$crate</span><span class="color-white">::vec::from_elem(</span><span class="color-red">$elem</span><span class="color-white">, </span><span class="color-red">$n</span><span class="color-white">))</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">    );</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">    ($(</span><span class="color-red">$x</span><span class="color-white">:expr),+ $(,)?) =&gt; (</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">        <span class="color-red">$crate</span><span class="color-white">::__rust_force_expr!(&lt;[_]&gt;::into_vec(</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-white">            // This rustc_box is not required, but it produces a dramatic improvement in compile</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-white">            // time when constructing arrays with many elements.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">            #[rustc_box]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code">            <span class="color-red">$crate</span><span class="color-white">::boxed::Box::new([$(</span><span class="color-red">$x</span><span class="color-white">),+])</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code"><span class="color-white">        ))</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code"><span class="color-white">    );</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(2)" class="copy-fenced-code">Copy</button></pre><p>There are 3 cases of a vector initialization. If a programmer wants an empty vector, it calls <a href="#vecvecnew"><code class="inline-code-span">vec::Vec::new()</code></a>. It guarantees that it doesn&apos;t allocate any memory when an empty vector is initialized. If a programmer initializes vector like <code class="inline-code-span">vec![x; 100]</code>, it calls <a href="#vecfromelem"><code class="inline-code-span">vec::from_elem</code></a>. Click the link to see the explanation of the function.</p><p>For the last branch, which is the most common way to define a vector, wraps a buffer with <code class="inline-code-span">Box</code> and calls <code class="inline-code-span">into_vec</code>.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gray">// library/alloc/src/slice.rs</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-violet">pub fn </span><span class="color-aqua">into_vec</span><span class="color-white">&lt;T, A: Allocator&gt;(</span><span class="color-red">b</span><span class="color-white">: Box&lt;[T], A&gt;) -&gt; Vec&lt;T, A&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">unsafe </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> len = b.</span><span class="color-emerald">len</span><span class="color-white">();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-violet">let </span><span class="color-white">(b, alloc) = Box::into_raw_with_allocator(b);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">        Vec::from_raw_parts_in(b as *</span><span class="color-violet">mut</span><span class="color-white"> T, len, len, alloc)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"><span class="color-gray">// library/alloc/src/vec/mod.rs</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">inline</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">unstable</span><span class="color-white">(feature = &quot;</span><span class="color-green">allocator_api</span><span class="color-white">&quot;, issue = &quot;</span><span class="color-green">32838</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">    <span class="color-violet">pub unsafe fn </span><span class="color-aqua">from_raw_parts_in</span><span class="color-white">(</span><span class="color-red">ptr</span><span class="color-white">: *</span><span class="color-violet">mut</span><span class="color-white"> T, </span><span class="color-red">length</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">, </span><span class="color-red">capacity</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">, </span><span class="color-red">alloc</span><span class="color-white">: A) -&gt; </span><span class="color-violet">Self </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">        <span class="color-violet">unsafe </span><span class="color-white">{ Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(3)" class="copy-fenced-code">Copy</button></pre><p><code class="inline-code-span">into_vec</code> extracts information needed for the initialization of a vector, then calls <code class="inline-code-span">Vec::from_raw_parts_in</code>. An interesting part here is that the capacity and the length are the same. It doesn&apos;t allocate additional space for future push operations.</p><h2 id="read-an-element-of-a-vector">Read an element of a vector</h2><p>How does it access an element of a vector? It goes through quite complicated steps. Below are some important functions in the steps. The functions below are called from top to bottom.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-gray">// library/alloc/src/vec/mod.rs</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;T, I: SliceIndex&lt;[T]&gt;, A: Allocator&gt; Index&lt;I&gt; </span><span class="color-violet">for </span><span class="color-white">Vec&lt;T, A&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">type </span><span class="color-white">Output = I::Output;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">inline</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-violet">fn </span><span class="color-aqua">index</span><span class="color-white">(&amp;</span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">index</span><span class="color-white">: I) -&gt; &amp;</span><span class="color-violet">Self::</span><span class="color-white">Output {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">        Index::index(&amp;**</span><span class="color-red">self</span><span class="color-white">, index)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code"><span class="color-gray">// core/src/slice/index.rs</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">stable</span><span class="color-white">(feature = &quot;</span><span class="color-green">slice_get_slice_impls</span><span class="color-white">&quot;, since = &quot;</span><span class="color-green">1.15.0</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">rustc_const_unstable</span><span class="color-white">(feature = &quot;</span><span class="color-green">const_slice_index</span><span class="color-white">&quot;, issue = &quot;</span><span class="color-green">none</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-violet">unsafe impl</span><span class="color-white">&lt;T&gt; SliceIndex&lt;[T]&gt; </span><span class="color-violet">for </span><span class="color-white">usize {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">    <span class="color-violet">type </span><span class="color-white">Output = T;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">inline</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code">    <span class="color-violet">fn </span><span class="color-aqua">get</span><span class="color-white">(</span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">slice</span><span class="color-white">: &amp;[T]) -&gt; Option&lt;&amp;T&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code">        <span class="color-gray">// SAFETY: `self` is checked to be in bounds.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code">        <span class="color-violet">if </span><span class="color-red">self </span><span class="color-white">&lt; slice.</span><span class="color-emerald">len</span><span class="color-white">() { </span><span class="color-violet">unsafe </span><span class="color-white">{ Some(&amp;*</span><span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">get_unchecked</span><span class="color-white">(slice)) } } </span><span class="color-violet">else </span><span class="color-white">{ None }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">23</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">inline</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">24</span><span class="code-fence-code">    <span class="color-violet">unsafe fn </span><span class="color-aqua">get_unchecked</span><span class="color-white">(</span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">slice</span><span class="color-white">: *const [T]) -&gt; *</span><span class="color-violet">const</span><span class="color-white"> T {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">25</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> this = </span><span class="color-red">self</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">26</span><span class="code-fence-code">        <span class="color-gray">// SAFETY: the caller guarantees that `slice` is not dangling, so it</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">27</span><span class="code-fence-code">        <span class="color-gray">// cannot be longer than `isize::MAX`. They also guarantee that</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">28</span><span class="code-fence-code">        <span class="color-gray">// `self` is in bounds of `slice` so `self` cannot overflow an `isize`,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">29</span><span class="code-fence-code">        <span class="color-gray">// so the call to `add` is safe.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">30</span><span class="code-fence-code">        <span class="color-violet">unsafe </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">31</span><span class="code-fence-code"><span class="color-white">            assert_unsafe_precondition!(</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">32</span><span class="code-fence-code"><span class="color-white">                &quot;</span><span class="color-green">slice::get_unchecked requires that the index is within the slice</span><span class="color-white">&quot;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">33</span><span class="code-fence-code"><span class="color-white">                [T](this: </span><span class="color-violet">usize</span><span class="color-white">, slice: *</span><span class="color-violet">const </span><span class="color-white">[T]) =&gt; this &lt; slice.</span><span class="color-emerald">len</span><span class="color-white">()</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">34</span><span class="code-fence-code"><span class="color-white">            );</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">35</span><span class="code-fence-code"><span class="color-white">            slice.</span><span class="color-emerald">as_ptr</span><span class="color-white">().</span><span class="color-emerald">add</span><span class="color-white">(</span><span class="color-red">self</span><span class="color-white">)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">36</span><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">37</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">38</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">39</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(4)" class="copy-fenced-code">Copy</button></pre><p>It first checks whether the index is in bounds. If so, it returns the pointer of the desired element by adding the index to the pointer of the buffer.</p><h2 id="push-an-element-to-a-vector">Push an element to a vector</h2><p>Pushing an element is more complex than reading/initializing because it may change the metadata of a vector. Let&apos;s see how <code class="inline-code-span">.push</code> is defined.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">cfg</span><span class="color-white">(</span><span class="color-aqua">not</span><span class="color-white">(no_global_oom_handling))]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">inline</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">stable</span><span class="color-white">(feature = &quot;</span><span class="color-green">rust1</span><span class="color-white">&quot;, since = &quot;</span><span class="color-green">1.0.0</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-violet">pub fn </span><span class="color-aqua">push</span><span class="color-white">(&amp;</span><span class="color-violet">mut </span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">value</span><span class="color-white">: T) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">    <span class="color-gray">// This will panic or abort if we would allocate &gt; isize::MAX bytes</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-gray">// or if the length increment would overflow for zero-sized types.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">    <span class="color-violet">if </span><span class="color-red">self</span><span class="color-white">.len == </span><span class="color-red">self</span><span class="color-white">.buf.</span><span class="color-emerald">capacity</span><span class="color-white">() {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.buf.</span><span class="color-emerald">reserve_for_push</span><span class="color-white">(</span><span class="color-red">self</span><span class="color-white">.len);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">    <span class="color-violet">unsafe </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> end = </span><span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">as_mut_ptr</span><span class="color-white">().</span><span class="color-emerald">add</span><span class="color-white">(</span><span class="color-red">self</span><span class="color-white">.len);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code"><span class="color-white">        ptr::write(end, value);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.len += </span><span class="color-gold">1</span><span class="color-white">;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(5)" class="copy-fenced-code">Copy</button></pre><p>The <code class="inline-code-span">push</code> method itself is very simple. It checks whether the capacity is available, then writes a new value at the end of the buffer. If there&apos;s no enough capacity, it calls <code class="inline-code-span">.reserve_for_push</code>. It&apos;s what we&apos;re interested in.</p><pre class="fenced-code-block line-num-width-2"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;T, A: Allocator&gt; RawVec&lt;T, A&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-violet">pub</span><span class="color-white">(</span><span class="color-violet">crate</span><span class="color-white">) </span><span class="color-violet">const </span><span class="color-gold">MIN_NON_ZERO_CAP</span><span class="color-white">: </span><span class="color-violet">usize </span><span class="color-white">= </span><span class="color-violet">if </span><span class="color-white">mem::size_of::&lt;T&gt;() == </span><span class="color-gold">1 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">        <span class="color-gold">8</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">    } </span><span class="color-violet">else if </span><span class="color-white">mem::size_of::&lt;T&gt;() &lt;= </span><span class="color-gold">1024 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">        <span class="color-gold">4</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">    } </span><span class="color-violet">else </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">        <span class="color-gold">1</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-white">    };</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">    <span class="color-gray">/// A specialized version of `reserve()` used only by the hot and</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">    <span class="color-gray">/// oft-instantiated `Vec::push()`, which does its own capacity check.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">cfg</span><span class="color-white">(</span><span class="color-aqua">not</span><span class="color-white">(no_global_oom_handling))]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">inline</span><span class="color-white">(never)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">    <span class="color-violet">pub fn </span><span class="color-aqua">reserve_for_push</span><span class="color-white">(&amp;</span><span class="color-violet">mut </span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">len</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code">        <span class="color-emerald">handle_reserve</span><span class="color-white">(</span><span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">grow_amortized</span><span class="color-white">(len, </span><span class="color-gold">1</span><span class="color-white">));</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;T, A: Allocator&gt; RawVec&lt;T, A&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">23</span><span class="code-fence-code">    <span class="color-violet">fn </span><span class="color-aqua">set_ptr_and_cap</span><span class="color-white">(&amp;</span><span class="color-violet">mut </span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">ptr</span><span class="color-white">: NonNull&lt;[</span><span class="color-violet">u8</span><span class="color-white">]&gt;, </span><span class="color-red">cap</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">24</span><span class="code-fence-code">        <span class="color-gray">// Allocators currently return a `NonNull&lt;[u8]&gt;` whose length matches</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">25</span><span class="code-fence-code">        <span class="color-gray">// the size requested. If that ever changes, the capacity here should</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">26</span><span class="code-fence-code">        <span class="color-gray">// change to `ptr.len() / mem::size_of::&lt;T&gt;()`.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">27</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.ptr = </span><span class="color-violet">unsafe </span><span class="color-white">{ Unique::new_unchecked(ptr.</span><span class="color-emerald">cast</span><span class="color-white">().</span><span class="color-emerald">as_ptr</span><span class="color-white">()) };</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">28</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.cap = cap;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">29</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">30</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">31</span><span class="code-fence-code">    <span class="color-gray">// This method is usually instantiated many times. So we want it to be as</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">32</span><span class="code-fence-code">    <span class="color-gray">// small as possible, to improve compile times. But we also want as much of</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">33</span><span class="code-fence-code">    <span class="color-gray">// its contents to be statically computable as possible, to make the</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">34</span><span class="code-fence-code">    <span class="color-gray">// generated code run faster. Therefore, this method is carefully written</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">35</span><span class="code-fence-code">    <span class="color-gray">// so that all of the code that depends on `T` is within it, while as much</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">36</span><span class="code-fence-code">    <span class="color-gray">// of the code that doesn&apos;t depend on `T` as possible is in functions that</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">37</span><span class="code-fence-code">    <span class="color-gray">// are non-generic over `T`.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">38</span><span class="code-fence-code">    <span class="color-violet">fn </span><span class="color-aqua">grow_amortized</span><span class="color-white">(&amp;</span><span class="color-violet">mut </span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">len</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">, </span><span class="color-red">additional</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">) -&gt; Result&lt;(), TryReserveError&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">39</span><span class="code-fence-code">        <span class="color-gray">// This is ensured by the calling contexts.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">40</span><span class="code-fence-code"><span class="color-white">        debug_assert!(additional &gt; </span><span class="color-gold">0</span><span class="color-white">);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">41</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">42</span><span class="code-fence-code">        <span class="color-violet">if </span><span class="color-white">T::</span><span class="color-gold">IS_ZST </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">43</span><span class="code-fence-code">            <span class="color-gray">// Since we return a capacity of `usize::MAX` when `elem_size` is</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">44</span><span class="code-fence-code">            <span class="color-gray">// 0, getting to here necessarily means the `RawVec` is overfull.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">45</span><span class="code-fence-code">            <span class="color-violet">return </span><span class="color-white">Err(CapacityOverflow.</span><span class="color-emerald">into</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">46</span><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">47</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">48</span><span class="code-fence-code">        <span class="color-gray">// Nothing we can really do about these checks, sadly.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">49</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> required_cap = len.</span><span class="color-emerald">checked_add</span><span class="color-white">(additional).</span><span class="color-emerald">ok_or</span><span class="color-white">(CapacityOverflow)?;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">50</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">51</span><span class="code-fence-code">        <span class="color-gray">// This guarantees exponential growth. The doubling cannot overflow</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">52</span><span class="code-fence-code">        <span class="color-gray">// because `cap &lt;= isize::MAX` and the type of `cap` is `usize`.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">53</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> cap = cmp::max(</span><span class="color-red">self</span><span class="color-white">.cap * </span><span class="color-gold">2</span><span class="color-white">, required_cap);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">54</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> cap = cmp::max(</span><span class="color-violet">Self</span><span class="color-white">::</span><span class="color-gold">MIN_NON_ZERO_CAP</span><span class="color-white">, cap);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">55</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">56</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> new_layout = Layout::array::&lt;T&gt;(cap);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">57</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">58</span><span class="code-fence-code">        <span class="color-gray">// `finish_grow` is non-generic over `T`.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">59</span><span class="code-fence-code">        <span class="color-violet">let</span><span class="color-white"> ptr = </span><span class="color-emerald">finish_grow</span><span class="color-white">(new_layout, </span><span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">current_memory</span><span class="color-white">(), &amp;</span><span class="color-violet">mut </span><span class="color-red">self</span><span class="color-white">.alloc)?;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">60</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">set_ptr_and_cap</span><span class="color-white">(ptr, cap);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">61</span><span class="code-fence-code"><span class="color-white">        Ok(())</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">62</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">63</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">64</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">65</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">66</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">inline</span><span class="color-white">(never)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">67</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">finish_grow</span><span class="color-white">&lt;A&gt;(</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">68</span><span class="code-fence-code">    <span class="color-red">new_layout</span><span class="color-white">: Result&lt;Layout, LayoutError&gt;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">69</span><span class="code-fence-code">    <span class="color-red">current_memory</span><span class="color-white">: Option&lt;(NonNull&lt;</span><span class="color-violet">u8</span><span class="color-white">&gt;, Layout)&gt;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">70</span><span class="code-fence-code">    <span class="color-red">alloc</span><span class="color-white">: &amp;</span><span class="color-violet">mut</span><span class="color-white"> A,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">71</span><span class="code-fence-code"><span class="color-white">) -&gt; Result&lt;NonNull&lt;[</span><span class="color-violet">u8</span><span class="color-white">]&gt;, TryReserveError&gt;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">72</span><span class="code-fence-code"><span class="color-violet">where</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">73</span><span class="code-fence-code"><span class="color-white">    A: Allocator,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">74</span><span class="code-fence-code"><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">75</span><span class="code-fence-code">    <span class="color-gray">// Check for the error here to minimize the size of `RawVec::grow_*`.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">76</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> new_layout = new_layout.</span><span class="color-emerald">map_err</span><span class="color-white">(|_| CapacityOverflow)?;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">77</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">78</span><span class="code-fence-code">    <span class="color-emerald">alloc_guard</span><span class="color-white">(new_layout.</span><span class="color-emerald">size</span><span class="color-white">())?;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">79</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">80</span><span class="code-fence-code">    <span class="color-violet">let</span><span class="color-white"> memory = </span><span class="color-violet">if let </span><span class="color-white">Some((ptr, old_layout)) = current_memory {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">81</span><span class="code-fence-code"><span class="color-white">        debug_assert_eq!(old_layout.</span><span class="color-emerald">align</span><span class="color-white">(), new_layout.</span><span class="color-emerald">align</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">82</span><span class="code-fence-code">        <span class="color-violet">unsafe </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">83</span><span class="code-fence-code">            <span class="color-gray">// The allocator checks for alignment equality</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">84</span><span class="code-fence-code"><span class="color-white">            intrinsics::assume(old_layout.</span><span class="color-emerald">align</span><span class="color-white">() == new_layout.</span><span class="color-emerald">align</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">85</span><span class="code-fence-code"><span class="color-white">            alloc.</span><span class="color-emerald">grow</span><span class="color-white">(ptr, old_layout, new_layout)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">86</span><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">87</span><span class="code-fence-code"><span class="color-white">    } </span><span class="color-violet">else </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">88</span><span class="code-fence-code"><span class="color-white">        alloc.</span><span class="color-emerald">allocate</span><span class="color-white">(new_layout)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">89</span><span class="code-fence-code"><span class="color-white">    };</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">90</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">91</span><span class="code-fence-code"><span class="color-white">    memory.</span><span class="color-emerald">map_err</span><span class="color-white">(|_| AllocError { layout: new_layout, non_exhaustive: () }.</span><span class="color-emerald">into</span><span class="color-white">())</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">92</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">93</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">94</span><span class="code-fence-code"><span class="color-gray">// Central function for reserve error handling.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">95</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">cfg</span><span class="color-white">(</span><span class="color-aqua">not</span><span class="color-white">(no_global_oom_handling))]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">96</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">inline</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">97</span><span class="code-fence-code"><span class="color-violet">fn </span><span class="color-aqua">handle_reserve</span><span class="color-white">(</span><span class="color-red">result</span><span class="color-white">: Result&lt;(), TryReserveError&gt;) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">98</span><span class="code-fence-code">    <span class="color-violet">match</span><span class="color-white"> result.</span><span class="color-emerald">map_err</span><span class="color-white">(|</span><span class="color-red">e</span><span class="color-white">| e.</span><span class="color-emerald">kind</span><span class="color-white">()) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">99</span><span class="code-fence-code"><span class="color-white">        Err(CapacityOverflow) =&gt; </span><span class="color-emerald">capacity_overflow</span><span class="color-white">(),</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">100</span><span class="code-fence-code"><span class="color-white">        Err(AllocError { layout, .. }) =&gt; </span><span class="color-emerald">handle_alloc_error</span><span class="color-white">(layout),</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">101</span><span class="code-fence-code"><span class="color-white">        Ok(()) =&gt; { </span><span class="color-gray">/* yay */ </span><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">102</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">103</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(6)" class="copy-fenced-code">Copy</button></pre><p>Well, that&apos;s quite long. When a buffer doesn&apos;t have any more space, it calls <code class="inline-code-span">reserve_for_push</code> to grow the size of the vector. It first calls <code class="inline-code-span">grow_amortized</code>, which determines the capacity of the new vector, and allocates the actual memory. <code class="inline-code-span">handle_reserve</code> checks whether the allocation was successful.</p><p><code class="inline-code-span">grow_amortized</code> takes 2 arguments: current length and the number of additional elements of the vector. For our <code class="inline-code-span">push</code> case, <code class="inline-code-span">additional</code> is 1. It first tries to double the size of the buffer. If the doubled buffer is still not big enough, it makes the buffer size exactly <code class="inline-code-span">len + additional</code>. If the new capacity is smaller than the minial required capacity, it grows the capacity again. <code class="inline-code-span">MIN_NON_ZERO_CAP</code> is defined at line 3 above. It&apos;s 8 for byte-sized types, 4 for small types and 1 for big ones. <code class="inline-code-span">finish_grow</code> actually allocates the new memory, and makes sure that the newly allocated memory is valid.</p><div class="box"><p>In case you wonder what the line 42 means...</p><p>For 0-sized types, it doesn&apos;t allocate any space. It sets capacity to be <code class="inline-code-span">usize::MAX</code> for 0-sized types. Since this function is called only when <code class="inline-code-span">length &gt;= capacity</code>, line 42 is true only when the programmer tries to push more than <code class="inline-code-span">usize::MAX</code> elements to a vector. It returns <code class="inline-code-span">Err(CapacityOverflow)</code> in such case.</p></div><h2 id="for-rust-programmers">For Rust programmers</h2><p>Above sections contain some useful information for Rust programmers. First, when we initialize a vector using <code class="inline-code-span">vec!</code>, it doesn&apos;t allocate additional space. The length and the capacity are the same. When we push an element, a vector is guaranteed to have a capacity of at least 4 elements (for most types). If the capacity is to grow, it&apos;s doubled.</p><h2 id="appendix">Appendix</h2><h3 id="vecvecnew"><code class="inline-code-span">vec::Vec::new()</code></h3><p><a id="vecvecnew"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">inline</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">rustc_const_stable</span><span class="color-white">(feature = &quot;</span><span class="color-green">const_vec_new</span><span class="color-white">&quot;, since = &quot;</span><span class="color-green">1.39.0</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">stable</span><span class="color-white">(feature = &quot;</span><span class="color-green">rust1</span><span class="color-white">&quot;, since = &quot;</span><span class="color-green">1.0.0</span><span class="color-white">&quot;)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">must_use</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-violet">pub const fn </span><span class="color-aqua">new</span><span class="color-white">() -&gt; </span><span class="color-violet">Self </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">    Vec { buf: RawVec::</span><span class="color-gold">NEW</span><span class="color-white">, len: </span><span class="color-gold">0 </span><span class="color-white">}</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(7)" class="copy-fenced-code">Copy</button></pre><p>Below is the definition of <code class="inline-code-span">RawVec::NEW</code>.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;T&gt; RawVec&lt;T, Global&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code">    <span class="color-gray">/// HACK(Centril): This exists because stable `const fn` can only call stable `const fn`, so</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-gray">/// they cannot call `Self::new()`.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">    <span class="color-gray">///</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">    <span class="color-gray">/// If you change `RawVec&lt;T&gt;::new` or dependencies, please take care to not introduce anything</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code">    <span class="color-gray">/// that would truly const-call something unstable.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">    <span class="color-violet">pub const </span><span class="color-gold">NEW</span><span class="color-white">: </span><span class="color-violet">Self </span><span class="color-white">= </span><span class="color-violet">Self</span><span class="color-white">::new();</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">    <span class="color-gray">/// Creates the biggest possible `RawVec` (on the system heap)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">    <span class="color-gray">/// without allocating. If `T` has positive size, then this makes a</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">    <span class="color-gray">/// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">    <span class="color-gray">/// `RawVec` with capacity `usize::MAX`. Useful for implementing</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">    <span class="color-gray">/// delayed allocation.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">must_use</span><span class="color-white">]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">    <span class="color-violet">pub const fn </span><span class="color-aqua">new</span><span class="color-white">() -&gt; </span><span class="color-violet">Self </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code">        <span class="color-violet">Self</span><span class="color-white">::new_in(Global)</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(8)" class="copy-fenced-code">Copy</button></pre><p>As the comment says, it guarantees that <code class="inline-code-span">Vec::new()</code> doesn&apos;t allocate any memory.</p><h3 id="vecfrom_elem"><code class="inline-code-span">vec::from_elem()</code></h3><p><a id="vecfromelem"></a></p><pre class="fenced-code-block line-num-width-0"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;T: Clone&gt; SpecFromElem </span><span class="color-violet">for </span><span class="color-white">T {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">    default </span><span class="color-violet">fn </span><span class="color-aqua">from_elem</span><span class="color-white">&lt;A: Allocator&gt;(</span><span class="color-red">elem</span><span class="color-white">: </span><span class="color-violet">Self</span><span class="color-white">, </span><span class="color-red">n</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">, </span><span class="color-red">alloc</span><span class="color-white">: A) -&gt; Vec&lt;</span><span class="color-violet">Self</span><span class="color-white">, A&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">        <span class="color-violet">let mut</span><span class="color-white"> v = Vec::with_capacity_in(n, alloc);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">        v.</span><span class="color-emerald">extend_with</span><span class="color-white">(n, ExtendElement(elem));</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-white">        v</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(9)" class="copy-fenced-code">Copy</button></pre><p>It calls <code class="inline-code-span">.extend_with</code> with the element and <code class="inline-code-span">n</code>. <code class="inline-code-span">ExtendElement</code> is a generator that endlessly clones <code class="inline-code-span">elem</code>. That&apos;s why <code class="inline-code-span">T</code> has to satisfy <code class="inline-code-span">Clone</code>.</p><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-violet">impl</span><span class="color-white">&lt;T, A: Allocator&gt; Vec&lt;T, A&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">    #[</span><span class="color-red">cfg</span><span class="color-white">(</span><span class="color-aqua">not</span><span class="color-white">(no_global_oom_handling))]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code">    <span class="color-gray">/// Extend the vector by `n` values, using the given generator.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code">    <span class="color-violet">fn </span><span class="color-aqua">extend_with</span><span class="color-white">&lt;E: ExtendWith&lt;T&gt;&gt;(&amp;</span><span class="color-violet">mut </span><span class="color-red">self</span><span class="color-white">, </span><span class="color-red">n</span><span class="color-white">: </span><span class="color-violet">usize</span><span class="color-white">, </span><span class="color-violet">mut </span><span class="color-red">value</span><span class="color-white">: E) {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code">        <span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">reserve</span><span class="color-white">(n);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code">        <span class="color-violet">unsafe </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code">            <span class="color-violet">let mut</span><span class="color-white"> ptr = </span><span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">as_mut_ptr</span><span class="color-white">().</span><span class="color-emerald">add</span><span class="color-white">(</span><span class="color-red">self</span><span class="color-white">.</span><span class="color-emerald">len</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code">            <span class="color-gray">// Use SetLenOnDrop to work around bug where compiler</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">            <span class="color-gray">// might not realize the store through `ptr` through self.set_len()</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">            <span class="color-gray">// don&apos;t alias.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">            <span class="color-violet">let mut</span><span class="color-white"> local_len = SetLenOnDrop::new(&amp;</span><span class="color-violet">mut </span><span class="color-red">self</span><span class="color-white">.len);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">            <span class="color-gray">// Write all elements except the last one</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">            <span class="color-violet">for </span><span class="color-white">_ in </span><span class="color-gold">1</span><span class="color-white">..n {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code"><span class="color-white">                ptr::write(ptr, value.</span><span class="color-emerald">next</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">                ptr = ptr.</span><span class="color-emerald">add</span><span class="color-white">(</span><span class="color-gold">1</span><span class="color-white">);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">18</span><span class="code-fence-code">                <span class="color-gray">// Increment the length in every step in case next() panics</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">19</span><span class="code-fence-code"><span class="color-white">                local_len.</span><span class="color-emerald">increment_len</span><span class="color-white">(</span><span class="color-gold">1</span><span class="color-white">);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">20</span><span class="code-fence-code"><span class="color-white">            }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">21</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">22</span><span class="code-fence-code">            <span class="color-violet">if</span><span class="color-white"> n &gt; </span><span class="color-gold">0 </span><span class="color-white">{</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">23</span><span class="code-fence-code">                <span class="color-gray">// We can write the last element directly without cloning needlessly</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">24</span><span class="code-fence-code"><span class="color-white">                ptr::write(ptr, value.</span><span class="color-emerald">last</span><span class="color-white">());</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">25</span><span class="code-fence-code"><span class="color-white">                local_len.</span><span class="color-emerald">increment_len</span><span class="color-white">(</span><span class="color-gold">1</span><span class="color-white">);</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">26</span><span class="code-fence-code"><span class="color-white">            }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">27</span><span class="code-fence-code"></span></span>
<span class="code-fence-row"><span class="code-fence-index">28</span><span class="code-fence-code">            <span class="color-gray">// len set by scope guard</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">29</span><span class="code-fence-code"><span class="color-white">        }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">30</span><span class="code-fence-code"><span class="color-white">    }</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">31</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(10)" class="copy-fenced-code">Copy</button></pre><p>As mentioned above, <code class="inline-code-span">ExtendWith</code> is an endless generator. <code class="inline-code-span">.next()</code> at line 16 clones <code class="inline-code-span">value</code>.</p><h3 id="unique"><code class="inline-code-span">Unique</code></h3><p><a id="uniqueptr"></a></p><p>The explanation below is from the comment in the compiler source code.</p><div class="box"><pre class="fenced-code-block line-num-width-1"><code><span class="code-fence-row"><span class="code-fence-index">1</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">unstable</span><span class="color-white">(</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">2</span><span class="code-fence-code"><span class="color-white">    feature = &quot;</span><span class="color-green">ptr_internals</span><span class="color-white">&quot;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">3</span><span class="code-fence-code"><span class="color-white">    issue = &quot;</span><span class="color-green">none</span><span class="color-white">&quot;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">4</span><span class="code-fence-code"><span class="color-white">    reason = &quot;</span><span class="color-green">use `NonNull` instead and consider `PhantomData&lt;T&gt;` \</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">5</span><span class="code-fence-code"><span class="color-green">              (if you also use `#[may_dangle]`), `Send`, and/or `Sync`</span><span class="color-white">&quot;</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">6</span><span class="code-fence-code"><span class="color-white">)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">7</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">doc</span><span class="color-white">(hidden)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">8</span><span class="code-fence-code"><span class="color-white">#[</span><span class="color-red">repr</span><span class="color-white">(transparent)]</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">9</span><span class="code-fence-code"><span class="color-violet">pub struct </span><span class="color-white">Unique&lt;T: </span><span class="color-dark">?</span><span class="color-white">Sized&gt; {</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">10</span><span class="code-fence-code">    <span class="color-red">pointer</span><span class="color-white">: NonNull&lt;T&gt;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">11</span><span class="code-fence-code">    <span class="color-gray">// NOTE: this marker has no consequences for variance, but is necessary</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">12</span><span class="code-fence-code">    <span class="color-gray">// for dropck to understand that we logically own a `T`.</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">13</span><span class="code-fence-code">    <span class="color-gray">//</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">14</span><span class="code-fence-code">    <span class="color-gray">// For details, see:</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">15</span><span class="code-fence-code">    <span class="color-gray">// https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">16</span><span class="code-fence-code">    <span class="color-red">_marker</span><span class="color-white">: PhantomData&lt;T&gt;,</span></span></span>
<span class="code-fence-row"><span class="code-fence-index">17</span><span class="code-fence-code"><span class="color-white">}</span></span></span>
</code><button onclick="copy_code_to_clipboard(11)" class="copy-fenced-code">Copy</button></pre><p>A wrapper around a raw non-null <code class="inline-code-span">*mut T</code> that indicates that the possessor of this wrapper owns the referent. Useful for building abstractions like <code class="inline-code-span">Box&lt;T&gt;</code>, <code class="inline-code-span">Vec&lt;T&gt;</code>, <code class="inline-code-span">String</code>, and <code class="inline-code-span">HashMap&lt;K, V&gt;</code>.</p><p>Unlike <code class="inline-code-span">*mut T</code>, <code class="inline-code-span">Unique&lt;T&gt;</code> behaves &quot;as if&quot; it were an instance of <code class="inline-code-span">T</code>. It implements <code class="inline-code-span">Send</code>/<code class="inline-code-span">Sync</code> if <code class="inline-code-span">T</code> is <code class="inline-code-span">Send</code>/<code class="inline-code-span">Sync</code>. It also implies the kind of strong aliasing guarantees an instance of <code class="inline-code-span">T</code> can expect: the referent of the pointer should not be modified without a unique path to its owning Unique.</p><p>If you&apos;re uncertain of whether it&apos;s correct to use <code class="inline-code-span">Unique</code> for your purposes, consider using <code class="inline-code-span">NonNull</code>, which has weaker semantics.</p><p>Unlike <code class="inline-code-span">*mut T</code>, the pointer must always be non-null, even if the pointer is never dereferenced. This is so that enums may use this forbidden value as a discriminant -- <code class="inline-code-span">Option&lt;Unique&lt;T&gt;&gt;</code> has the same size as <code class="inline-code-span">Unique&lt;T&gt;</code>. However the pointer may still dangle if it isn&apos;t dereferenced.</p><p>Unlike <code class="inline-code-span">*mut T</code>, <code class="inline-code-span">Unique&lt;T&gt;</code> is covariant over <code class="inline-code-span">T</code>. This should always be correct for any type which upholds Unique&apos;s aliasing requirements.</p></div><script>/*<![CDATA[*/
const fenced_code_block_contents = ["#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"Vec\")]\n#[rustc_insignificant_dtor]\npub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    buf: RawVec<T, A>,\n    len: usize,\n}", "#[allow(missing_debug_implementations)]\npub(crate) struct RawVec<T, A: Allocator = Global> {\n    ptr: Unique<T>,\n    cap: usize,\n    alloc: A,\n}", "#[cfg(all(not(no_global_oom_handling), not(test)))]\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_diagnostic_item = \"vec_macro\"]\n#[allow_internal_unstable(rustc_attrs, liballoc_internals)]\nmacro_rules! vec {\n    () => (\n        $crate::__rust_force_expr!($crate::vec::Vec::new())\n    );\n    ($elem:expr; $n:expr) => (\n        $crate::__rust_force_expr!($crate::vec::from_elem($elem, $n))\n    );\n    ($($x:expr),+ $(,)?) => (\n        $crate::__rust_force_expr!(<[_]>::into_vec(\n            // This rustc_box is not required, but it produces a dramatic improvement in compile\n            // time when constructing arrays with many elements.\n            #[rustc_box]\n            $crate::boxed::Box::new([$($x),+])\n        ))\n    );\n}", "// library/alloc/src/slice.rs\npub fn into_vec<T, A: Allocator>(b: Box<[T], A>) -> Vec<T, A> {\n    unsafe {\n        let len = b.len();\n        let (b, alloc) = Box::into_raw_with_allocator(b);\n        Vec::from_raw_parts_in(b as *mut T, len, len, alloc)\n    }\n}\n\n// library/alloc/src/vec/mod.rs\nimpl<T, A: Allocator> Vec<T, A> {\n    #[inline]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    pub unsafe fn from_raw_parts_in(ptr: *mut T, length: usize, capacity: usize, alloc: A) -> Self {\n        unsafe { Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }\n    }\n}", "// library/alloc/src/vec/mod.rs\nimpl<T, I: SliceIndex<[T]>, A: Allocator> Index<I> for Vec<T, A> {\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n        Index::index(&**self, index)\n    }\n}\n\n// core/src/slice/index.rs\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\nunsafe impl<T> SliceIndex<[T]> for usize {\n    type Output = T;\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&T> {\n        // SAFETY: `self` is checked to be in bounds.\n        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n    }\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n        let this = self;\n        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n        // cannot be longer than `isize::MAX`. They also guarantee that\n        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n        // so the call to `add` is safe.\n        unsafe {\n            assert_unsafe_precondition!(\n                \"slice::get_unchecked requires that the index is within the slice\",\n                [T](this: usize, slice: *const [T]) => this < slice.len()\n            );\n            slice.as_ptr().add(self)\n        }\n    }\n\n}", "#[cfg(not(no_global_oom_handling))]\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn push(&mut self, value: T) {\n    // This will panic or abort if we would allocate > isize::MAX bytes\n    // or if the length increment would overflow for zero-sized types.\n    if self.len == self.buf.capacity() {\n        self.buf.reserve_for_push(self.len);\n    }\n    unsafe {\n        let end = self.as_mut_ptr().add(self.len);\n        ptr::write(end, value);\n        self.len += 1;\n    }\n}", "impl<T, A: Allocator> RawVec<T, A> {\n\n    pub(crate) const MIN_NON_ZERO_CAP: usize = if mem::size_of::<T>() == 1 {\n        8\n    } else if mem::size_of::<T>() <= 1024 {\n        4\n    } else {\n        1\n    };\n\n    /// A specialized version of `reserve()` used only by the hot and\n    /// oft-instantiated `Vec::push()`, which does its own capacity check.\n    #[cfg(not(no_global_oom_handling))]\n    #[inline(never)]\n    pub fn reserve_for_push(&mut self, len: usize) {\n        handle_reserve(self.grow_amortized(len, 1));\n    }\n\n}\n\nimpl<T, A: Allocator> RawVec<T, A> {\n\n    fn set_ptr_and_cap(&mut self, ptr: NonNull<[u8]>, cap: usize) {\n        // Allocators currently return a `NonNull<[u8]>` whose length matches\n        // the size requested. If that ever changes, the capacity here should\n        // change to `ptr.len() / mem::size_of::<T>()`.\n        self.ptr = unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) };\n        self.cap = cap;\n    }\n\n    // This method is usually instantiated many times. So we want it to be as\n    // small as possible, to improve compile times. But we also want as much of\n    // its contents to be statically computable as possible, to make the\n    // generated code run faster. Therefore, this method is carefully written\n    // so that all of the code that depends on `T` is within it, while as much\n    // of the code that doesn't depend on `T` as possible is in functions that\n    // are non-generic over `T`.\n    fn grow_amortized(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n        // This is ensured by the calling contexts.\n        debug_assert!(additional > 0);\n\n        if T::IS_ZST {\n            // Since we return a capacity of `usize::MAX` when `elem_size` is\n            // 0, getting to here necessarily means the `RawVec` is overfull.\n            return Err(CapacityOverflow.into());\n        }\n\n        // Nothing we can really do about these checks, sadly.\n        let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n\n        // This guarantees exponential growth. The doubling cannot overflow\n        // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n        let cap = cmp::max(self.cap * 2, required_cap);\n        let cap = cmp::max(Self::MIN_NON_ZERO_CAP, cap);\n\n        let new_layout = Layout::array::<T>(cap);\n\n        // `finish_grow` is non-generic over `T`.\n        let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n        self.set_ptr_and_cap(ptr, cap);\n        Ok(())\n    }\n\n}\n\n#[inline(never)]\nfn finish_grow<A>(\n    new_layout: Result<Layout, LayoutError>,\n    current_memory: Option<(NonNull<u8>, Layout)>,\n    alloc: &mut A,\n) -> Result<NonNull<[u8]>, TryReserveError>\nwhere\n    A: Allocator,\n{\n    // Check for the error here to minimize the size of `RawVec::grow_*`.\n    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n\n    alloc_guard(new_layout.size())?;\n\n    let memory = if let Some((ptr, old_layout)) = current_memory {\n        debug_assert_eq!(old_layout.align(), new_layout.align());\n        unsafe {\n            // The allocator checks for alignment equality\n            intrinsics::assume(old_layout.align() == new_layout.align());\n            alloc.grow(ptr, old_layout, new_layout)\n        }\n    } else {\n        alloc.allocate(new_layout)\n    };\n\n    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())\n}\n\n// Central function for reserve error handling.\n#[cfg(not(no_global_oom_handling))]\n#[inline]\nfn handle_reserve(result: Result<(), TryReserveError>) {\n    match result.map_err(|e| e.kind()) {\n        Err(CapacityOverflow) => capacity_overflow(),\n        Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n        Ok(()) => { /* yay */ }\n    }\n}", "#[inline]\n#[rustc_const_stable(feature = \"const_vec_new\", since = \"1.39.0\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[must_use]\npub const fn new() -> Self {\n    Vec { buf: RawVec::NEW, len: 0 }\n}", "impl<T> RawVec<T, Global> {\n    /// HACK(Centril): This exists because stable `const fn` can only call stable `const fn`, so\n    /// they cannot call `Self::new()`.\n    ///\n    /// If you change `RawVec<T>::new` or dependencies, please take care to not introduce anything\n    /// that would truly const-call something unstable.\n    pub const NEW: Self = Self::new();\n\n    /// Creates the biggest possible `RawVec` (on the system heap)\n    /// without allocating. If `T` has positive size, then this makes a\n    /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n    /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n    /// delayed allocation.\n    #[must_use]\n    pub const fn new() -> Self {\n        Self::new_in(Global)\n    }\n}", "impl<T: Clone> SpecFromElem for T {\n    default fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n        let mut v = Vec::with_capacity_in(n, alloc);\n        v.extend_with(n, ExtendElement(elem));\n        v\n    }\n}", "impl<T, A: Allocator> Vec<T, A> {\n    #[cfg(not(no_global_oom_handling))]\n    /// Extend the vector by `n` values, using the given generator.\n    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n        self.reserve(n);\n\n        unsafe {\n            let mut ptr = self.as_mut_ptr().add(self.len());\n            // Use SetLenOnDrop to work around bug where compiler\n            // might not realize the store through `ptr` through self.set_len()\n            // don't alias.\n            let mut local_len = SetLenOnDrop::new(&mut self.len);\n\n            // Write all elements except the last one\n            for _ in 1..n {\n                ptr::write(ptr, value.next());\n                ptr = ptr.add(1);\n                // Increment the length in every step in case next() panics\n                local_len.increment_len(1);\n            }\n\n            if n > 0 {\n                // We can write the last element directly without cloning needlessly\n                ptr::write(ptr, value.last());\n                local_len.increment_len(1);\n            }\n\n            // len set by scope guard\n        }\n    }\n}", "#[unstable(\n    feature = \"ptr_internals\",\n    issue = \"none\",\n    reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n              (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\"\n)]\n#[doc(hidden)]\n#[repr(transparent)]\npub struct Unique<T: ?Sized> {\n    pointer: NonNull<T>,\n    // NOTE: this marker has no consequences for variance, but is necessary\n    // for dropck to understand that we logically own a `T`.\n    //\n    // For details, see:\n    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n    _marker: PhantomData<T>,\n}"];

function copy_code_to_clipboard(index) {
    navigator.clipboard.writeText(fenced_code_block_contents[index]);
}/*]]>*/</script>
        <a id="bottom"></a>
    </article>




    <footer class="markdown">
<p><br/></p><p><br/></p><hr/><div class="align-center"><p>2021 ~ 2023 &copy; Baehyunsol</p></div>
    </footer>


    <script src="colors.js"></script>

    
    <script src="nav.js"></script>
    
    
    
    <script src="header.js"></script>
    
</body>

</html>